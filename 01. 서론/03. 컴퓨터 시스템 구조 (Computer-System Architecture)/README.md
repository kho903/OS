# 1.3 컴퓨터 시스템 구조 (Computer-System Architecture)
- 컴퓨터 시스템은 사용된 범용 프로세서의 수에 따라 분류 가능한 다양한 방식으로 구성될 수 있다.

## 1.3.1 단일 처리기(프로세서) 시스템 (Single-Processor Systems)
- 몇년전 대부분 컴퓨터 시스템은 하나의 CPU를 포함하는 단일 프로세서 사용. 
- 코어는 명령을 실행하고 로컬로 데이터를 저장히기 위한 레지스터이다. 코어가 있는 하나의 메인 CPU는 프로세스 명령을 포함하여 범용 명령어
세트를 실행할 수 있다. 이러한 시스템에는 다른 특수 목적 프로세서도 있다. 디스크, 키보드 및 그래픽 컨트롤러와 같은 장치별 프로세서
형태도 제공될 수 있다.
- 이 모든 전용 프로세서는 제한된 명령 집합을 실행하고 사용자 프로세스를 실행하지는 않는다. 때로는 운영체제가 다음 작업에 대한 정보를 보내고
상태를 모니터링한다는 점에서 운영 체제에 의해 관리됨. 예를 들어 디스크 컨트롤러 마이크로프로세서는 주 CPU로부터 연속된 요청을 받아들여
자기 고유의 디스크 큐와 스케줄링 알고리즘을 구현한다. 이 배열은 CPU가 직접 스케줄링을 해야 하는 오버헤드를 감소시킨다. 
- PC의 키보드는 키스트로크를 CPU에 전송할 코드로 변환하는 마이크로프로세서를 가지고 있다. 다른 시스템 또는 환경에서는 전용 프로세서가
하드웨어로 구현되는 저수준의 구성요소이다. 운영체제는 이러한 프로세서들과 통신할 수 없으며 독립적으로 자신의 작업을 처리. 
- 특수 목적 마이크로프로세서의 사용은 일반적인 형태이며 그렇다고 단일 프로세서 시스템을 다중 프로세서 시스템으로 변환하지는 않는다.
단일 프로세서 코어를 가진 범용 CPU가 하나만 있는 경우 시스템은 단일 프로세서 시스템이다. 그러나, 이 정의에 따르면 현대 컴퓨터 시스템은
단일 프로세서 시스템이 거의 없다.

## 1.3.2 다중 처리기(멀티 프로세서) 시스템 (Multiprocessor Systems)
- 최신 컴퓨터에는 다중 프로세서 시스템이 컴퓨팅 환경을 지배하고 있다. 일반적으로 각각 단일 코어 CPU가 있는 두 개 이상의 프로세서가
있다. 프로세서는 컴퓨터 버스 및 때때로 컴퓨터 버스 및 때때로 클록, 메모리 및 주변 장치를 공유한다. 다중 처리기 시스템의 주요 장점은 
처리량 증가이다. 즉, 프로세서 수를 늘리면 짧은 시간에 많은 작업을 수행할 수 있다. 
- 그러나 N 프로세서의 속도 향상 비율은 N이 아니다. 여러 프로세서가 하나의 작업에 협력할 때 모든 프로세서가 올바르게 작동하게 유지하는 
데 어느 정도의 오버헤드가 발생한다. 이 오버헤드와 공유 자원에 대한 경합은 추가 프로세서의 예상되는 이득을 낮춘다.
- 가장 일반적인 다중 프로세서 시스템은 각 피어 CPU 프로세서가 운영체제 기능 및 사용자 프로세스를 포함한 모든 작업을 수행하는
SMP (symmetric multiprocessing)를 사용한다. 각 CPU 프로세서에는 고유한 레지스터 집합과 개인 또는 로컬 케시 있다.
그러나 모든 프로세서는 시스템 버스를 통해 물리 메모리를 공유.
- 이 모델의 장점은 성능을 크게 저하시키지 않고, 많은 프로세서를 동시에 실행시킬 수 있다는 점입니다. N개 CPU가 있는 경우 N개의
프로세스를 실행할 수 있다. 그러나 CPU가 분리되어 있기 때문에 하나는 유휴 상태 (어떠한 프로그램에 의해서도 사용되지 않는 상태)이고, 
다른 하나는 과부하 사태가 되어 비효율적일 수 있다. 프로세서가 특정 자료구조를 공유하는 경우 이러한 비효율성을 피할 수 있다.
- 이 형태의 다중 프로세서 시스템은 프로세스 및 메모리와 같은 자원을 다양한 프로세서 간에 동적으로 공유할 수 있게 하고,
프로세서 간의 작업 부하 분산을 낮출 수 있다.
- 다중 처리기(멀티프로세서)의 정의는 시간이 지남에 따라 발전했으며 이제 단일 칩에 여러 개의 컴퓨팅 코어가 존재하는 
다중(멀티) 코어 시스템을 포함한다. 칩 내 통신이 칩 간 통신보다 빨라 단일 코어가 있는 가지는 여러 칩보다 더 효율적.
또한 여러 개의 코어가 있는 하나의 칩은 여러 개의 단일 코어 칩보다 훨씬 적은 전력을 사용하는데, 이는 노트북, 모바일 장치의 중요한 문제.
- 같은 프로세서 칩에 두 개의 코어를 가지는 이중(듀얼) 코어 설계에서 각 코어에는 자체 레지스터 세트와 레벨1 (L1) 캐시라고하는 자체
캐시가 있다. 또한 레벨2 (L2)캐시는 칩에 국한되지만 두 처리 코어에서 공유.
- 대부분의 아키텍처는 로컬 및 공유 캐시를 결합하여 이 접근 방식을 채택한다. 여기서 로컬 하위 레벨 캐시는 일반적으로 상위 레벨 공유 캐시보다
작고 빠르다. 캐시, 메모리 및 버스 경합과 같은 아키텍처 고려 사항 외에도 N 코어를 가지는 다중(멀티) 코어 프로세서는 운영체제에 N개의
CPU처럼 보인다. 이러한 특성은 운영체제 설계자 및 응용 프로그램 프로그래머가 이러한 처리 코어를 효율적으로 사용하도록 압력을 가한다.
- Windows, macOS, Linux, Android 및 Linux를 포함한 거의 모든 최신 운영 체제 iOS 모바일 시스템도 멀티(다중) 코어 SMP 시스템을 지원
- 다중 프로세서 시스템에 CPU를 추가하면 컴퓨터 성능이 향상됨. 그러나 앞선 부분에서처럼 이러한 개념은 그다지 확장성이 좋지 않고, CPU를
너무 많이 추가하면 시스템 버스에 대한 경합이 병목 현상으로 성능 저하가 발생한다. 다른 방법은 각 CPU(CPU 그룹)에 작고 빠른 로컬 버스를 통해
액세스 되는 자체 로컬 메모리를 제공하는 것. 모든 CPU가 공유 시스템 연결로 연결되어 모든 CPU가 하나의 물리 메모리 주소 공간을 공유한다.
- NUMA(non-uniform memory access) 로 또는 비균일 메모리 액세스로 알려진 이 접근 방식의 장점은 CPU가 로컬 메모리에 액세스할 때
빠를 뿐만 아니라 시스템 상호 연결에 대한 경합도 없다는 것. 따라서 NUMA 시스템은 더 많은 프로세서가 추가될수록 더 효과적으로 확장 가능
- NUMA 시스템의 잠재적 단점은 CPU가 시스템 상호 연결을 통해 원격 메모리에 액세스해야 할 떄 지연이 증가하여 성능 저하가 발생 가능하다는 점.
즉, CPU0 이 자체 로컬 메모리에 액세스 할 수 있는 만큼 빠르게 CPU3의 로컬 메모리에 액세스 할 수 없어 성능이 저하된다. 
운영체제는 신중한 CPU 스케줄링 및 메모리 관리를 통해 이 NUMA의 단점을 최소화. NUMA 시스템은 많은 수의 프로세서를 수용할 수 있도록 확장할
수 있으므로 고성능 컴퓨팅 시스템 뿐만 아니라 서버에서도 점점 인기를 얻고 있다.
- 마지막으로 블레이드 서버는 다수의 프로세서 보드, I/O 보드 및 네트워킹 보드를 동일한 섀시(chassis) 안에 장착되는 형태를 가진다.
블레이드 서버와 전통적인 다중 프로세서 시스템의 차이는 각 블레이드 프로세서 보드가 독립적으로 부팅되고 자체 운영 체제를 실행한다는 것이다.
일부 블레이드 서버 보드는 자체가 다중 프로세서 이기도 하며 이 사실은 컴퓨터 유형 간의 경계를 모호하게 만든다. 본질적으로 이 블레이드 서버는
여러 개의 독립적인 다중 프로세서 시스템으로 구성.

## 1.3.3 클러스터형 시스템 (Clustered Systems)
- 여러 CPU를 가진 시스템의 또 다른 유형은 클러스터형 시스템. 둘 이상의 독자적 시스템 또는 노드들을 연결하여 구성한다는 점에서 다중 프로세서
시스템과 차이가 난다. 각 노드는 일반적으로 멀티코어 시스템이다. 그러한 시스템은 약결합 (느슨한 결합, loosely coupled) 으로 간주된다.
- 클러스터형(clustred)의 정의는 분명하지 않다. 많은 상용 및 오픈 소스 패키지는 클러스터형 시스템이 무엇인지, 왜 한 형태가 다른
형태보다 좋은지에 대한 문제에 답을 제시하는 데 어려움을 겪고 있따. 일반적으로 인정되는 정의에 의하면 클러스터 컴퓨터는 저장장치를 공유하고
근거리 통신망 (LAN, locla area network) 또는 InfiniBand와 같은 고속의 상호 연결망(interconnect)으로 연결된다.
- 클러스터링은 일반적으로 고가용성 (availability)를 제공하기 위해 사용된다. 클러스터 내 하나 이상의 시스템이 고장나더라도 서비스는
계속 제공된다. 일반적으로 시스템에 중복 기능을 추가함으로써 얻을 수 있다. 클러스터 소프트웨어 중 한 층에 클러스터 노트에서 실행된다.
각 노드는 하나 이상의 다른 노드 (네트워크로 연결된)들을 감시. 만일 감시받던 노드가 고장 나면 감시하던 노드가 고장 난 노드의 저장장치에 대한
소유권을 넘겨받고, 그 노드에서 실행 중이던 응용 프로그램을 다시 시작. 사용자와 응용 프로그램의 클라이언트는 잠깐의 서비스 중단만을 경험.

- 고가용성은 많은 애플리케이션에서 중요한 향상된 안정성을 제공한다. 남아 있는 하드웨어 수준에 비례하여 서비스를 계속 제공할 수 있는 기능을
우아한 성능 저하(graceful degradation)라고 한다. 일부 시스템은 정상적인 성능 저하를 넘어 단일 구성요소에 오류가 발생하여도 계속
작동할 수 있으므로 결함허용 시스템이라고 한다. 결함허용에는 장애를 감지, 진단 및 가능한 경우 수정할 수 있는 기법이 필요하다.
- 클러스터링은 비대칭 또는 대칭적으로 구성될 수 있다. 
- 비대칭 클러스터링에서는 다른 컴퓨터들이 응용 프로그램을 실행하는 동안 한 컴퓨터는 긴급 대기 (hot-standby)모드 상태를 유지. 이
긴급 대기 모드의 호스트는 활성 서버를 감시하는 것 외에 아무 작업도 수행하지 않는다. 해당 서버에 장애가 발생하면 긴급 대기 모드의 호스트가 
활성 서버가 된다.
- 대칭형 클러스터링에서는 둘 이상의 호스트가 응용 프로그램을 실행하고 서로를 감시한다. 가용한 하드웨어를 모두 사용하기 때문에 대칭형 구성이
더 효율적. 그러나, 효율적으로 동작하기 위해서는 둘 이상의 응용 프로그램이 실행가능해야 한다.
- 한 클러스터가 네트워크로 연결된 다수의 컴퓨터 시스템으로 구성되므로 클러스터는 고성능 계산환경을 제공하도록 사용될 수 있다. 이러한
시스템은 클러스터의 모든 컴퓨터에서 응용 프로그램을 병령 수행할 수 있으므로 단일 프로세서나 SMP 시스템 보다 훨씬 더 큰 계산 능력을 
제공할 수 있다. 
- 그렇지만 응용프로그램은 클러스터를 이용할 수 있도록 특별히 작성되어야 함. 이는 병렬화라는 기법으로 프로그램을 컴퓨터의 
개별 코어 또는 클러스터의 각 컴퓨터에서 수행되는 분리된 요소로 나누는 작업을 포함. 일반적으로 이러한 응용프로그램은 클러스터의 각 계산 
노드가 문제 일부를 해결한 후 모든 노드의 결과를 결합하여 최종 해답을 얻게 된다.
- 다른 형태의 클러스터로 병렬 (parallel) 클러스터와 WAN(wide-area-network)을 이용한 클러스터링이 존재. 
- 병렬 클러스터를 사용하면 여러 호스트가 공유 스토리지의 동일한 데이터에 접근할 수 있다.
- 대부분의 운영 체제는 여러 호스트의 동시 데이터 접근을 지원하지 않기 때문에 병렬 클러스터는 일반적으로 특수 버전의 소프트웨어와 특별히 발매된
응용프로그램을 사용해야 한다. 예를 들어 Oracle Real Application Cluster는 병렬 클러스터에서 수행하도록 설계된 Oracle 데이터베이스
버전. 각 시스템은 Oracle을 실행하고 하나의 소프트웨어 층이 공유 디스크에 대한 접근을 관리. 각 시스템은 데이터베이스의 모든 데이터에 대한
전체 액세스 권한을 가짐. 이 공유 액세스를 제공하기 위해 시스템은 충돌하는 작업이 발생하지 않도록 액세스 제어 및 잠금도 제공해야 함.
일반적으로 분산 잠금 관리자 (distributed lock manager, DLM)라고 불리는 이 기능은 일부 클러스터 기술에 포함됨.
- 클러스터 기술은 급변하고 있따. 어떤 클러스터 제품은 수 킬로미터 떨어진 클러스터 노드들 뿐만아니라, 한 클러스터 안에서 수천 개의 노드를 지원.
- 이러한 계산은 스토리지 전용 네트워크(storage-area network, SAN)에 의해 가능해짐. SAN은 여러 호스트를 여러 저장장치에 부착할 수
있게 함. 만일 응용프로그램과 데이터가 SAN에 저장된다면 클러스터 소프트웨어는 SAN에 연결된 임의의 호스트에서 수행되도록 응용프로그램을
할당할 수 있다. 호스트가 고장 나면 다른 호스트가 그 응용 프로그램을 넘겨 받는다. 데이터베이스 클러스터에서는 수십 개의 호스트가 동일한 
데이터베이스를 공유할 수 있기 때문에 성능과 신뢰도를 매우 증가시키게 된다.

