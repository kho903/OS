# 1.4 운영체제의 작동 (Operating-System Operations)
- 컴퓨터 시스템 구성 및 아키텍처에 대한 기본 정보를 살펴보았으므로 이제 운영체제를 보자.
- 운영체제는 프로그램이 실행되는 환경을 제공한다. 내부적으로 운영체제는 여러 경로를 거쳐 구성되기 때문에 운영체제마다 큰 차이를 보인다.
그러나 많은 공통점이 존재하고 이 절에서 그것을 다룬다.
- 컴퓨터의 전원을 켜거나 재부팅과 같이 컴퓨터를 실행하려면 초기 프로그램을 실행해야 한다. 초기 프로그램 또는 부트 스트랩 프로그램은 단순한 경향이 있다.
일반적으로 컴퓨터 하드웨어 내에 펌웨어로 저장된다. CPU 레지스터에서 장치 컨트롤러, 메모리 내용에 이르기까지 시스템의 모든 측면을 초기화한다. 부트스트랩
프로그램은 운영체제를 로드하는 방법과 해당 시스템 실행을 시작하는 방법을 알아야 한다. 이 목표를 달성하기 위해 부트스트랩 프로그램은 운영 체제 커널을 찾아
메모리에 로드해야 한다.
- 커널이 로드되어 실행되면 시스템과 사용자에게 서비스를 제공할 수 있다. 일부 서비스는 커널이 실행되는 전체 시간 동안 실행되느 시스템 데몬이 되기 위해
부팅할 때 로드되는 시스템 프로그램에 의해 커널 외부에서 제공된다. Linux에서 첫 번째 시스템 프로그램은 "systemd"이며, 다른 많은 데몬을 시작한다.
이 단계가 완료되면 시스템이 완전히 부팅되고 시스템은 어떤 이벤트가 발생할 때까지 기다린다.
- 실행할 프로세스, 서비스할 I/O 장치, 응답할 사용자가 없는 경우 운영체제는 조용히 앉아서 어떤 일이 일어나기를 기다린다. 이벤트는 거의 항상 인터럽트를
발생시켜 신호를 보낸다. 앞에서 본 인터럽트와 또 다른 형태의 인터럽트는 트랩 (또는 예외)으로, 오류 (예 : 0으로 나누거나 유효ㅛ하지 않은 메모리 액세스)
꼬응 사용자 프로그램의 특정 요청 때문에 발생하는 소프트퉤어 생성 인터럽트이다. 이 특정 요청은 시스템 콜이라는 특수 연산을 실행하여 요청되고 운영체제가
제공하는 서비스가 수행될 것을 요구한다.

## 1.4.1 다중(멀티) 프로그래밍과 다중(멀티) 태스킹 (multiprogramming and multitasking)
- 운영 체제의 가장 중요한 측면 중 하나는 일반적으로 단일 프로그램이 CPU 또는 I/O 장치를 항상 사용중인 상태로 유지할 수 없기 떄문에 여러 프로그램을 
실행할 수 있는 기능이다. 또한 사용자는 일반적으로 한 번에 둘 이상의 프로그램을 실행하기를 원한다. 멀티 프로그래밍은 CPU가 항상 한 개는 실행할 수 
있도록 프로그램을 구성하여 CPU 이용률을 높이고 사용자 만족도를 높인다. 멀티 프로그램 시스템에서 실행 중인 프로그램을 프로세스라 한다.
- 운영체제는 여러 프로세스를 동시에 메모리에 유지한다. 운영체제는 이러한 프로세스 중 하나를 선택하여 실행하기 시작한다. 결국 프로세스는 I/O 작업과 같은
일부 작업이 완료되기를 기다려야 할 수도 있다. 멀티 프로그램 되지 않은 시스템에서는 CPU가 유휴 상태일 수 있다. 멀티 프로그램 시스템에서 운영체제는
단순히 다른 프로세스로 전환하여 실행한다. 해당 프로세스가 대기해야 하는 경우, CPU는 다른 프로세스로 전환한다. 결국 첫 번째 프로세스는 대기를 마치고 CPU를
다시 돌려받는다. 적어도 하나의 프로세스를 실행해야 하는 한 CPU는 결코 유휴 상태가 아니다.
- 이 아이디어는 다른 일상생활에서도 볼 수 있는데, 변호사가 한 사람의 의뢰를 맡고 결과를 기다릴 때, 다른 사건을 처리할 수 있다. 충분히 많은 의뢰인을
확보하고 있다면 일이 없어서 쉬는 일은 발생하지 않는다. 
- 멀티 태스킹은 멀티 프로그래밍의 논리적 확장이다. 멀티 테스킹 시스템에서 CPU는 여러 프로세스를 전환하여 프로세스를 실행하진지만 전환이 자주 발생하여
사용자에게 빠른 응답시간을 제공한다. 프로세스가 실행될 때 일반적으로 완료되거나, I/O를 수행해야 하기 전에 짧은 시간 동안만 실행된다.
입출력은 대화식일 수 있다. 즉, 출력은 사용자를 위한 디스플레이로 이동하고, 입력은 사용자 키보드, 마우스, 터치스크린으로부터 들어온다. 이러한 대화식 입출력은
전형적으로 사람의 속도로 수행되므로, 완료하는 데 오랜 시간이 걸릴 수 있다. 예를 들어 입력은 사용자의 타이핑 속도에 제한을 받는다. 이러한 대화식 입력이
진행되는 동안 CPU를 쉬게하지 않고, 운영체제는 CPU를 다른 사용자의 프로그램으로 신속하게 전환한다.
- 동시에 여러 프로세스를 메모리에 유지하려면 메모리 관리 방식이 필요하다. 또한 여러 프로세스가 동시에 실행할 준비가 되면 시스템은 다음에 실행할 프로세스를
선택해야 한다. 이 결정을 내리는 것은 CPU 스케줄링이다. 마지막으로, 여러 프로세스를 동시에 실행하려면 프로세스 스케줄링, 디스크 저장장치 및 메모리 관리를
포함하여 운영체제의 모든 단계에서 서로 영향을 미치는 기능이 제한되어야 한다. 
- 멀티 태스킹 시스템에서 운영체제는 적절한 응답시간을 보장해야 한다. 더 일반적인 방법은 가상 메모리(virtual memory)인데, 메모리에 일부만 메모리에 적재된
프로세스의 실행을 허용하는 기법. 이 기법의 주요 장점은 프로그램이 물리 메모리의 크기보다 더 커도 된다는 것이다. 더욱이 가상 메모리는 메인 메모리를 크고
균등한 저장장치의 배열로 추상화하여 사용자에게 보이는 논리 메모리를 물리 메모리로부터 분리시킨다. 이러한 기법은 프로그래머를 메모리 저장장치의 한계로부터 
자유롭게 해준다. 
- 멀티 프로그래밍 및 멀티 테스킹 시스템도 파일 시스템을 제공해야 한다. 파일 시스템은 보조 저장장치에 존재한다. 따라서 저장장치 관리가 제공되어야 한다.
또한 시스템은 부적절한 사용으로부터 자원을 보호해야 한다. 질서 있게 실행하려면 시스템은 프로세스 동기화 및 통신을 위한 기법을 제공해야 하며, 프로세스가
서로를 영원히 기다리는 교착 샅애에 빠지지 않도록 보장해야 한다.

## 1.4.2 이중-모드와 다중모드 운용 (Dual-Mode and Multimode Operation)
- 운영체제와 사용자는 컴퓨터 시스템의 하드웨어 및 소프트웨어 자원을 공유하기 때문에 올바르게 설계된 운영체제는 잘못된 (악의적인) 프로그램으로 인해 다른
프로그램 또는 운영체제 자체를 잘못 실행하지 못하도록 해야 한다. 시스템의 올바르게 실행하려면 운영체제 코드 실행과 사용자-정의 코드 실행을 구분할 수 있어야
한다. 대부분의 컴퓨터 시스템이 취하는 접근 방식은 다양한 실행 모드를 구분 할 수 있는 하드웨어 지원을 제공하는 것이다.
- 적어도 두 개의 독립된 연산 모드, 즉, 사용자 모드와 커널 모드 (수퍼바이저 모드, 시스템 모드, 혹은 특권 모드 (privileged mode))를 필요로 한다.
모드 비트(mode bit)라고 하는 하나의 비트가 현재의 모드를 나타내기 위해 컴퓨터의 하드웨어에 추가되었다. 이 비트는 커널 모드(0) 또는 사용자 모드(1)를
나타낸다. 모드 비트의 사용으로, 우리는 운영체제를 위해 실행되는 작업과 사용자를 위해 실행되는 작업을 구분할 수 있다. 컴퓨터 시스템이 사용자 애플리케이션을
위하여 실행될 때 시스템은 사용자 모드에 있게 된다. 그러나 사용자 애플리케이션이 운영 체제로부터 시스템 콜을 통해 서비스를 요청하면 이 요청을 수행하기
위해서는 사용자 모드에서 커널 모드로 전환해야 한다. 이러한 아키텍처 향상은 시스템 운영의 다른 많은 측면에서도 유용하다.
- 시스템 부팅시, 하드웨어는 커널모드에서 시작한다. 그런 다음 운영체제가 로드되고 사용자 모드에서 사용자 프로세스가 시작된다. 트랩이나 인터럽트가 발생할
때마다 하드웨어는 사용자 모드에서 커널 모드로 전환한다(즉, 모드 비트를 0으로 변경). 따라서, 운영체제가 컴퓨터를 제어할 때마다 커널 모드에 있게 된다.
시스템은 사용자 프로그램으로 제어를 넘기기 전에 항상 사용자 모드(모드 비트를 1로 설정)로 전환한다.
- 이중 작동 모드는 잘못된 사용자로부터 운영체제를 그리고 잘못된 사용자 서로를 보호하는 방법을 제공한다. 우리는 악영향을 끼칠 수 있는 일부 명령을 
특권 명령 (privileged instruction)으로 지정함으로써 이러한 보호를 수행한다. 하드웨어는 특권 명령이 커널 모드에서만 수행되도록 허용한다. 사용자
모드에서 특권 명령을 수행하려고 하면, 하드웨어는 이를 실행하지 않고, 불법적인 명령으로 간주해 운영체제로 트랩을 건다.
- 커널 모드로 전환하는 명령어가 특권 명령어의 예이다. 다른 예로는 I/O 제어, 타이머 관리 및 인터럽트 관리가 있다.
- 모드의 개념은 두 가지 모드 이상으로 확장될 수 있다. 예를 들어, Intel 프로세서에는 4개의 분리된 보호 링이 있다. 링0은 커널 모드, 링3은 사용자 모드.
(링 1, 2는 잘 사용되지 않는다.) ARMv8 시스템에는 7가지 모드가 있다. 가상화를 제어하는 시점을 표시하기 위한 별도의 모드를 가진다. 이 모드에서 VMM은
사용자 프로세스보다 많은 권한을 가지지만 커널보다는 적다. CPU 상태를 변경하여 가상 머신을 생성 및 관리할 수 있으려면 해당 수준의 권한이 필요하다.
- 우리는 이제 컴퓨터 시스템에서 명령어 실행의 수명주기를 더 잘 이해할 수 있다. 초기 제어는 커널 모드에서 명령어가 실행되는 운영 체제에 있다. 사용자
애플리케이션에 제어가 주어지면 모드가 사용자 모드로 설정된다. 결국, 인터럽트, 트랩 또는 시스템 콜을 통해 제어가 운영체제로 다시 전환된다.
Microsoft Windows, Unix 및 Linux와 같은 대부분의 최신 운영 체제는 이 이중 모드 기능을 활용하고, 운영체제에 대한 보호를 강화한다.
- 시스템 콜은 사용자 프로그램이 자신을 대신하여 운영체제에 예약된 작업을 수행하도록 운영체제에 요청하는 수단을 제공한다. 시스템 콜은 컴퓨터 시스템의
프로세서가 지원하는 기능에 따라 다양한 방법으로 호출된다. 시스템 콜은 운영체제에 의해 수행될 동작을 사용자 프로세스가 요청할 수 있게 한다. 시스템 콜은 
일반적으로 인터럽트 벡터의 특정 위치로 트랩을 거는 형태를 취한다. 이 트랩은 보통의 trap 명령어를 통해 수행되지만 일부 시스템은 syscall 이라는
특정 명령어를 가지기도 한다.
- 시스템 콜이 수행될 때, 하드웨어에 의해 하나의 소프트웨어 인터럽트로 취급된다. 제어가 인터럽트 벡터를 통해 운영체제 내의 서비스 루틴으로 전달되고,
모든 비트가 커널 모드로 설정된다. 시스템 콜 서비스 루틴은 운영체제의 일부이다. 커널은 인터럽트를 발생시킨 명령을 검사하여 어떤 시스템 콜이 발생했는지를
결정한다. 이 때 전달된 인수가 사용자 프로그램이 요청하는 서비스 유형을 표시한다. 요청이 필요로하는 추가의 정보는 레지스터, 스택 또는 메모리로 전달될 수
있다. 커널은 인수가 정확하고 합법적인지를 검증하고 요청을 수행한 후 제어를 시스템 콜 다음의 명령으로 복귀한다.
- 하드웨어 보호 기능이 제공되면 모드 규칙을 위반하는 오류가 하드웨어에 의해 탐지된다. 이러한 오류는 일반적으로 운영체제가 처리한다. 사용자 프로그램이 
잘못된 명령을 실행하거나 사용자의 주소 공간에 없는 메모리에 액세스하려는 등의 시도와 같은 오류가 발생하면, 하드웨어는 운영체제로 트랩을 발생시킨다.
- 트랩은 인터럽트처럼 인터럽트 벡터를 통해 제어를 운영체제에 넘긴다. 프로그램 오류가 발생하면 운영체제는 프로그램을 비정상적으로 종료해야 한다. 이 상황은
사용자가 요청한 비정상적인 종료와 동일한 코드로 처리된다. 적절한 오류 메시지가 주어지며, 프로그램의 메모리가 덤프된다. 메모리 덤프는 사용자나
프로그래머가 이를 조사하고, 프로그램을 수정하고 다시 시작할 수 있도록 통상 파일에 기록된다.

## 1.4.3 타이머 (Timer)
- 우리는 운영체제가 CPU에 대한 제어를 유지할 수 있도록 보장해야 한다. 우리는 사용자 프로그램이 무한 루프(infinite loop)에 빠지거나 시스템 호출에
실패하여, 제어가 운영체제로 복귀하지 않는 경우가 없도록 반드시 방지해야 한다. 이 목표를 달성하기 위해 타이머(timer)를 사용할 수 있다. 타이머는 지정된
시간 후에 컴퓨터를 인터럽트 하도록 설정할 수 있다. 이 시간은 고정(예 : 1/60초) 혹은 가변(1밀리초 ~ 1초) 일 수 있다.
- 가변 타이머는 일반적으로 고정률의 클록 (fixed-rate clock)과 계수기(counter)로 구현한다. 클운영체제는 계수기(counter)값을 설정한다.
카운터가 0이 될 때 인터럽트가 발생한다. 예를 들면, 1밀리초 클록의 10비트 카운터는 1밀리초 단위로 1밀리초 단위로 1밀리초에서 1,024 밀리초 사이의
간격으로 인터럽트를 허용한다.
- 사용자에게 제어권을 넘기기 전에, 운영체제는 타이머가 인터럽트를 할 수 있도록 설정되었는지를 확인한다. 만약 타이머가 인터럽트하면 제어는 자동으로
운영체제에 넘어가며, 운영체제는 인터럽트를 치명적인 오류로 간주하거나 프로그램에게 더 많은 시간을 줄 수 있다. 타이머의 값을 변경하는 명령은 명백히 
특권 명령이다.


