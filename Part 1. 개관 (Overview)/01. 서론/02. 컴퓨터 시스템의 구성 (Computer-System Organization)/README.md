# 1.2 컴퓨터 시스템의 구성 (Computer-System Organization)
- 현재 범용 컴퓨터 시스템은 구성 요소와 공유 메모리 사이에 액세스를 제공하는 공통 버스를 통해 연결된 하나 이상의 CPU와 여러 장치 컨트롤러로 구성된다.
- 각 장치 컨트롤러는 특정 유형의 장치(디스크 드라이브, 오디오 장치, 그래픽 디스플레이)를 담당한다. 컨트롤러에 따라 하나 이상의 장치가 연결될 수 있다.
- 예를 들어, 하나의 시스템 USB 포트는 여러 장치를 연결할 수 있는 USB 허브에 연결할 수 있다. 장치 컨트롤러는 일부 로컬 버퍼 저장소와 특수 목적 레지스터
집합을 유지 관리한다. 장치 컨트롤러는 제어하는 주변 장치와 로컬 버퍼 저장소 간에 데이터를 이동한다.
- 일반적으로 운영체제에는 각 장치 컨트롤러마다 장치 드라이버가 있다. 장치 컨트롤러의 작동을 잘 알고 있고 나머지 운영 체제에 장치에 대한 일관된 인터페이스 제공.
CPU와 장치 컨트롤러는 병렬로 실행되어 메모리 사이클을 놓고 경쟁한다. 공유 메모리를 질서있게 액세스하기 위해 메모리 컨트롤러는 메모리에 대한 액세스를 동기화한다.

## 1.2.1 인터럽트 (interrupts)
- 일반적인 컴퓨터 작업(입출력 수행)을 고려하자. 입출력 작업을 시작하기 위해 장치 드라이버는 장치 컨트롤러의 적절한 레지스터에 값을 적재.
- 그런 다음 장치 컨트롤러는 차례로 이러한 레지스터의 내용을 검사하여 수행할 작업 (키보드에서 문자 읽기 등)을 결정한다. 
- 컨트롤러는 장치에서 로컬 버퍼로 데이터 전송을 시작한다.
- 데이터 전송이 완료되면 장치 컨트롤러는 장치 드라이버에게 완료를 알린다.
- 그런 다음 장치 드라이버는 읽기 요청이면, 데이터 또는 데이터에 대한 포인터를 반환하여 운영체제의 다른 부분에 제어를 넘긴다. 다른 작업일 경우
드라이버는 "쓰기 완료" 또는 "장치 사용 중"과 같은 상태 정보를 반환한다.
- 컨트롤러는 장치드라이버에게 작업을 완료했다는 사실을 알리는 것을 인터럽트를 통해 알린다

### 1.2.1.1 개요 (Overview)
- 하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 언제든지 인터럽트를 발생시킬 수 있다. (컴퓨터 시스템 내에 많은 버스가 있을 수 있지만,
주요 통신 경로는 시스템 버스). 인터럽트는 다른 많은 용도로도 사용되며 운영체제와 하드웨어가 상호 작용하는 방식의 핵심 부분이다.
- CPU가 인터럽트되면, 하던 일을 멈추고 즉시 고정된 위치로 실향을 옮긴다. 고정 위치는 일반적으로 인터럽트에 대한 서비스 루틴이 위치한 시작 주소를 포함한다.
그리고 인터럽트 서비스 루틴이 실행된다. 완료되면, CPU는 인터럽트 되었던 연산을 재개한다.
- 인터럽트는 컴퓨터 구조의 중요한 부분으로 각 컴퓨터 설계에는 고유한 인터럽트 매커니즘을 가지고 있으며, 몇 가지 기능이 공통적이다.
- 인터럽트는 적절한 서비스 루틴으로 제어를 전달한다. 이러한 전달을 관리하는 간단한 방법은 인터럽트 정보를 조사하는 일반적인 루틴을 호출하는 것이다.
루틴은 차례대로 인터럽트 관련 핸들러를 호출한다.
- 그러나 인터럽트는 매우 자주 발생하기 때문에 빠르게 처리되어야 한다. 인터럽트 루틴에 대한 포인터들의 테이블을 이용해 필요한 속도를 제공할 수 있다.
이 경우, 중간 루틴이 필요 없이 테이블을 통해 간접적으로 호출될 수 있다. 일반적으로 포인터 테이블은 하위 메모리 (첫 100개 정도 위치)에 저장된다.
이 위치에는 다양한 장치에 대한 인터럽트 서비스 루틴의 주소가 들어 있다. 이 주소의 배열 또는 인터럽트 벡터는 인터럽트 요청과 함께 제공된 고유 번호로 인덱싱되어
인터럽트 장치에 인터럽트 서비스 루틴의 주소를 제공한다. Windows나 UNIX 같은 운영체제가 이러한 방식으로 인터럽트를 처리한다.
- 인터럽트 구조는 인터럽트를 처리한 후 이 정보를 복원할 수 있도록 인터럽트된 것의 상태 정보도 저장해야 한다. 인터럽트 루틴이 프로세서 상태를 수정해야 하는
경우 (예 : 레지스터 값 변경) 현재 상태를 명시적으로 저장한 다음 반환하기 전에 해당 상태를 복원해야 한다. 인터럽트가 서비스된 후 저장된 리턴 주소가
프로그램 카운터에 로드되고 인터럽트가 발생하지 않았던 것처럼 인터럽트된 연산이 재개된다.

### 1.2.1.2 구현 (implementation)
- 기본 인터럽트 매커니즘은 다음과 같이 작동한다.
- CPU 하드웨어에는 인터럽트 요청라인이라는 선이 있는데, 이는 하나의 명령어의 실행을 완료할 때 마다 CPU가 이 선을 감지한다.
- CPU가 컨트롤러가 인터럽트 요청 라인에 신호를 보낸 것을 감지하면, 인터럽트 번호를 읽고 해당 인터럽트 벡터의 인덱스를 사용하여 인터럽트 핸들러 루틴
  (interrupt-handler routine)으로 점프한다. 
- 그런 다음, 해당 인덱스와 관련된 주소에서 실행을 시작한다. 
- 인터럽트 핸들러는 작업 중에 변경된 상태를 저장하고, 인터럽트 원인을 확인하고, 필요한 처리를 수행하고, 상태 복원을 수행하고, return_from_interrupt
명령어를 실행하여 CPU를 인터럽트 전 실행 상태로 되돌린다.
- 장치 컨트롤러가 인터럽트 요청 라인에서 신호를 지정하여 인터럽트를 발생(raise)시키고, CPU는 인터럽트를 포착(catch)하여, 인터럽트 핸들러에 
디스패치(dispatch)하고 핸들러는 장치를 서비스하여 인터럽트를 지운다.(clear)
- 위의 기본 인터럽트 매커니즘은 장치 컨트롤러가 서비스할 준비가 될 때와 같은 비동기 이벤트에 CPU가 대응할 수 있게 한다. 그러나 최신 운영체제에서는
더욱 정교한 인터럽트 처리 기능이 필요하다.
1. 중요한 처리 중에 인터럽트 처리를 연기할 수 있어야 한다.
2. 장치에 대한 적절한 인터럽트 핸들러로 효율적으로 디스패치할 방법이 필요하다.
3. 운영 체제가 우선 순위가 높은 인터럽트와 낮은 인터럽트를 구별하고 적절한 긴급도로 대응할 수 있도록 다단계 (다중 레벨) 인터럽트가 필요하다.
- 최신 컴퓨터 하드웨어에서 이 세 가지 기능은 CPU 및 인터럽트 컨트롤러 하드웨어에 의해 제공된다.
- 대부분의 CPU에는 2개의 인터럽트 요청 라인이 있다. 하나는 복구할 수 없는 메모리 오류와 같은 이벤트를 위해 예약된 마스크 불가능 인터럽트 이다
  (nonmaskable interrupt). 두 번째 인터럽트 라인은 마스크 가능(maskable)이다.
- 인터럽트 되어서는 안 되는 중요한 명령 시퀀스를 실행하기 전에 CPU에 의해 해제될 수 있다. 마스크 가능한 인터럽트는 장치 컨트롤러에서
서비스를 요청하는 데 사용된다.
- 벡터 방식 인터럽트 기법의 목적은 하나의 인터럽트 핸들러가 서비스가 필요한 모든 인터럽트 소스를 검색할 필요성을 줄이기 위한 것이다.
- 그러나 실제로 컴퓨터에는 인터럽트 벡터에 주요 요소가 있는 것보다 더 많은 장치(인터럽트 핸들러) 가 있다. 이 문제를 해결하는 일반적인 방법은 인터럽트 벡터의
각 요소가 인터럽트 핸들러 목록의 헤드를 가리키는 인터럽트 체인을 사용하는 것이다. 인터럽트가 발생하면 해당 목록의 핸들러가 요청을 처리할 수 있는 핸들러를
찾을 때까지 하나씩 호출된다. 이 구조는 거대한 인터럽트 테이블의 오버헤드와 단일 인터럽트 핸들러에 대한 디스패치의 비효율성을 절출한 것이다.

| 벡터 번호  | 설명                     |
|--------|------------------------|
| 0      | 나눗셈 에러                 |
| 1      | 디버그 예외                 |
| 2      | Null 인터럽트              |
| 3      | 중단점(breakpoint)        |
| 4      | INTO-검출 오버플로           |
| 5      | 제한 범위 예외               |
| 6      | 유효하지 않은 opcode         |
| 7      | 장치 가용하지 않음             |
| 8      | 더블 폴트                  |
| 9      | 부터리기 세그먼트 침범(예약됨)      |
| 10     | 유효하지 않은 태스크 상태 세그먼트    |
| 11     | 존재하지 않는 세그먼트           |
| 12     | 스택 폴트                  |
| 13     | 일반 보호                  |
| 14     | 페이지 폴트                 |
| 15     | (Intel에서 예약, 사용하지 말 것) |
| 16     | 부동소수점 에러               |
| 17     | 정렬 검사                  |
| 18     | 기기 검사                  |
| 19-31  | (Intel에서 예약, 사용하지 말 것) |
| 32-255 | Maskable 인터럽트          |
- 위 표는 Intel 프로세서의 인터럽트 벡터 설계를 보여준다. 마스크 불가능한 0~31까지의 이벤트는 다양한 오류 조건을 알리는데 사용. 32-256는 장치가 생성한
인터럽트 같은 그 외 인터럽트를 처리하기 위해 사용됨
- 인터럽트 기법은 또한 인터럽트 우선순위 레벨(interrupt priority level)을 구현함. 이러한 레벨을 통해 CPU는 모든 인터럽트를 마스킹하지 않고도
우선순위가 낮은 인터럽트 처리를 연기 가능하고, 우선순위가 높은 인터럽트가 우선순위가 낮은 인터럽트의 실행을 선점 가능
- 즉, 인터럽트는 최신 운영체제에서 비동기 이벤트를 처리하기 위해 사용된다. 장치 컨트롤러 및 하드웨어 오류로 인해 인터럽트가 발생하고, 가장 긴급한
작업을 먼저 수행하기 위해 최신 컴퓨터는 인터럽트 우선순위 시스템을 사용한다. 인터럽트는 시간에 민감한 처리에 빈번하게 사용되므로 시스템 성능을 좋게 하려면
효율적인 인터럽트 처리가 필요.

## 1.2.2 저장장치 구조 (Storage Structure)
- CPU는 메모리에서만 명령을 로드할 수 있으므로 모든 프로그램은 실행하려면 먼저 메모리에 로드해야 한다.
- 범용 컴퓨터는 프로그램 대부분을 메인 메모리 (random-access memory 또는 RAM)라 불리는 재기록 가능한 메모리에서 가져온다.
- 메인 메모리는 dynamic random-access memory (DRAM)라 불리는 반도체 기술로 구현된다.
- 컴퓨터는 다른 형태의 메모리도 사용한다. 예를 들어, 전원을 켤 때 실행되는 첫 번째 프로그램은 부트스트랩 프로그램이며 운영체제를 로드한다.
- RAM은 휘발성이므로 부트스트랩 프로그램을 유지하는 용도로 사용할 수 없다. 대신 이 목적과 다른 목적으로, 컴퓨터는 전기적으로 소거 가능한 프로그램
가능 읽기 전용 메모리(EEPROM)과 기타 형태의 펌웨어(쓰기 작업이 자주 발생하지 않고 비활성인 저장장치)를 사용.
- EEPROM은 변경할 수는 있지만 자주 변경 불가. 속도가 느리므로 주로 사용되지 않는 정적 프로그램과 데이터가 포함됨 (예: 아이폰의 장치 일련번호)
- 모든 형태의 메모리는 바이트 배열을 제공한다. 각 바이트는 고유 주소가 있다. 상호 작용은 특정 메모리 주소들에 대한 일련의 적재(load), 또는
저장(store) 명령을 통해 이루어진다. 로드 명령은 메인 메모리로부터 CPU 내 내부 레지스터로한 바이트 또는 한 워드를 이동하는 반면, 
저장 명령은 레지스터의 내용을 메인 메모리로 ㅇ이동하는 것이다. 명시적인 로드 및 저장 외에 CPU는 프로그램 카운터에 저장된 위치부터 실행하기 위해
메인 메모리에서 명령을 자동으로 로드한다.
- 폰 노이만 구조 시스템에서 실행되는 일반적인 명령어 실행 주기는 먼저 메모리로부터 명령어를 가져와서 해당 명령어를 명령어 레지스터(instruction register)에
저장한다. 이어서 명령어를 해독하고, 메모리로부터 피연산자를 가져와 내부 레지스터에 저장될 수 있다.
- 피연산자에 대해 명령을 실행한 후 결과가 메모리에 다시 저장될 수 있다.
- 메모리 장치는 메모리 주소 스트림만 본다. 메모리 장치는 그것들이 어떻게 생성되는지 (명령 카운터(instruction counter), 색인(indexing),
간접 주소(indirection), 리터럴 주소(literal addressed) 등)또는 무엇을 위한 것인지(명령인지 데이터인지) 알 지 못한다. 따라서, 메모리
주소가 프로그램에 의해 어떻게 생성되었는지 무시할 수 있다. 우리는 단지 실행 중인 프로그램에 의해 생성된 메모리 주소 시퀀스에만 흥미가 있다.
- 이상적으로는 프로그램과 데이터가 메인 메모리에 존재하기를 원하지만 이는 대부분의 시스템에서 이와같은 이유로 불가능하다.
1. 메인 메모리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에는 너무 적다.
2. 메인 메모리는 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성 저장장치이다.
- 그러므로, 대부분 메인 메모리의 확장으로 보조저장장치를 제공한다. 주요 요구 사항은 영구적으로 저장할 수 있어야 한다는 점이다.
- 가장 일반적인 보조저장장치는 하드 디스크 드라이브(HDD)와 비휘발성 메모리(NVM) 장치로, 프로그램과 데이터 모두를 위한 저장소 제공
- 대부분의 프로그램(시스템 및 응용 프로그램)은 메모리에 적재될 때까지 보조저장장치에 저장됨. 많은 프로그램이 보조저장장치를 처리 소스 및 대상으로
모두 사용한다. 보조저장장치도 메인 메모리보다 훨씬 느리다.
- 그러나 더 큰 의미에서 레지스터, 메인 메모리 및 보조저장장치로 구성된 저장장치구조는 가능한 많은 저장 시스템 설계중 하나일 뿐이다. 다른 가능한
구성 요소는 캐시 메모리, CD-ROM 또는 블루레이, 자기 테이프 등이 있다. 다른 장치 저장 자료의 백업 사본 저장 위한 특수 목적으로 매우 느리지만
충분히 큰 장치를 3차 저장장치라고 한다. 각 저장장치 시스템은 데이터를 저장하고 나중에 검색될 때까지 해당 데이터를 유지하는 기본 기능을 제공.
다양한 저장장치 시스템 간의 주요 차이는 속도, 크기 및 휘발성(변동성).

```text
레지스터
|  |
캐시
|  |
메인 메모리 
-------------------- 1차 저장장치 (휘발성)
|  |
비휘발성 메모리
|  |
하드 디스크 드라이브
-------------------- 2차 저장장치
|  |
광학 디스크
|  |
자기 테이프
-------------------- 3차 저장장치
```
- 위와 같이 저장장치 용량과 액세스 시간에 따라 계층 구조로 구성될 수 있다.
- 최상위 4단계 메모리는 반도체 기반 전자회로로 구성된 반도체 메모리를 사용하여 구성된다. 네 번째 수준의 NVM 장치에는 여러 가지 변형이 있지만,
일반적으로 하드 디스크보다 빠르다. NVM 장치의 가장 일반적인 형태는 모바일 장치에서 널리 사용되는 플래시 메모리이다. 플래시 메모리는
랩톱, 데스크톱 및 서버에서도 장기 저정용으로 점차 사용되고 있다.
- 저장장치는 운영체제 구조에서 자주 나올 것이고, 아래와 같은 용어를 사용한다.
  - 휘발성 스토리지는 단순히 메모리이다.
  - 비휘발성 저장장치는 전원이 꺼졌을 때 내용을 유지한다. 이를 NVS라고 한다. 대부분의 경우 NVS는 보조저장장티를 가리킨다. 이 유형의
    저장장치는 다음 2가지 유형으로 분류된다.
    - 기계적 : 이러한 저장장치 시스템은 HDD, 광디스크, 홀로그램 저장장치 및 자기테이프.
    - 전기적 : 플래시 메모리, FRAM, NRAM 및 SSD이다. 
    - 기계적 저장장치는 일반적으로 전기적 저장장치보다 용량이 크고 바이트당 비용이 저렴하다.
    - 반대로 전기적 저장장치는 일반적으로 기계적 저장장치보다 비싸고 용량이 적으며 빠르다.
- 가능한 한 많은 저렴한 비휘발성 저장장치를 제공하는 동시에 필요한 만큼의 비싼 메모리를 사용해야 한다. 캐시는 두 구성요소 간에 액세스 시간이나
전송 속도의 차이가 큰 경우 성능을 향상하기 위해 설치할 수 있다.

## 1.2.3 입출력 구조 (I/O Structure)
- 운영체제 코드의 상당 부분은 시스템의 안정성과 성능에 대한 중요성과 장치의 다양한 특성으로 인해 I/O를 관리하는 데 사용된다.
- 범용 컴퓨터 시스템은 범용 버스를 통해 데이터를 교환하는 여러 장치로 구성되어 있다. 인터럽트 구동 I/O의 형태는 소량의 데이터를 이동하는 데는
괜찮지만, NVS I/O와 같은 대량 데이터 이동에 사용할 경우 높은 오버헤드를 발생시킬 수 있다. 이 문제를 해결하기 위해 DMA(Direct Memory Access)가
사용된다. 장치에 대한 버퍼 및 포인터, 입출력 카운터를 설정한 후 장티 컨트롤러는 CPU의 개입 없이 장치 및 메인 메모리와 직접 전체 데이터 블록을
전송한다. 속도가 느린 장치처럼 한 바이트마다 인터럽트가 발생되지 않고, 블록당 하나의 인터럽트만 발생되어 작업이 완료되었음을 장치 드라이버에 알린다.
장치 컨트롤러가 이러한작업을 수행하는 동안 CPU는 다른 작업을 수행할 수 있다.
- 일부 고가 시스템은 버스 대신 스위치 구조를 사용한다. 이러한 시스템에서 여러 구성요소는 공유 버스에서 주기를 놓고 경쟁하지 않고 동시에 다른
구성 요소와 통신할 수 있다. 이 경우 DMA의 사용은 훨씬 더 효과적이다.

