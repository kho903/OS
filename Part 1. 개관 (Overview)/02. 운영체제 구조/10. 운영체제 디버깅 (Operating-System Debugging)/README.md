# 2.10 운영체제 디버깅 (Operating-System Debugging)
- 넓게는 디버깅은 하드웨어와 소프트웨어에서의 시스템의 오류를 발견하고 수정하는 행위.
- 성능 문제는 버그로 간주되므로, 시스템에서 처리 중 발생하는 병목 현상 제거로 성능 향상시키려는 성능 조정 (performance tuning)도 디버깅에 포함.
- 이 장에서 커널과 프로세스 오류 및 성능 문제의 디버깅에 대한 탐구.

## 2.10.1 장애 분석 (Failure Analysis)
- 프로세스 실패시 대부분의 운영체제는 오류 정보를 로그 파일에 기록해 시스템 관리자나 사용자에게 문제가 발생했음을 알림.
- 운영체제는 프로세스가 사용하던 메모리를 캡처한 코어 덤프(core dump)를 취하고 차후 분석을 위해 파일로 저장. (초창기 시절, 메모리를 "코어"라고 부름)
- 실행 중인 프로그램과 코어 덤프는 디버거에 의해 검사될 수 있으며, 이는 장애 발생 시 프로그래머가 프로세스의 코드와 메모리를 분석할 수 있도록 함.
- 사용자 수준 프로세스 코드를 디버깅하는 것은 도전적인 일. 운영체제 커널 디버깅은 커널의 크기와 복잡성, 하드웨어 제어, 사용자 수준 디버깅 도구 부족으로 훨씬 복잡.
- 커널 장애는 크래시(crash)라고도 불림. 크래시 발생시 프로세스 장애와 마찬가지로, 오류 정보를 로그 파일에 저장하고 메모리 상태를 크래시 덤프(crash dump)에 저장.


- 운영체제 디버깅과 프로세스 디버깅은 종종 두 태스크의 근본적인 차이에 의해 서로 다른 도구와 기법 사용.
- 파일 시스템 코드 때문에 발생한 커널 장애는 재부팅 전에 커널의 상태를 파일 시스템에 저장하는 시도를 위험하게 함.
- 일반적인 기법은 커널의 메모리 상태를 이 용도를 위해 예약된 파일 시스템을 가지지 않는 디스크의 특정 부분에 저장하는 것.
- 커널이 복구 불가능한 오류를 탐지하면 메모리의 전체 내용 또는 적어도 시스템 메모리의 커널이 소유한 부분만이라도 이 디스크 영역에 저장.
- 시스템이 재부팅되면 프로세스는 이 영역으로부터 데이터를 수집하고 분석을 위해 파일 시스템의 크래시 덤프 파일에 기록.
- 분명하게 이러한 전략은 보통의 사용자 수준 프로세스를 디버깅하는 데에 필요하지 않다.

## 2.10.2 성능 관찰 및 조정 (Performance Monitoring and Tuning)
- 성능 조정은 처리 병목 지점을 제거함으로써 성능을 향상시키려 하는 것. 병목 지점 발견을 위해 시스템 성능을 감시할 수 있다.
- 따라서 시스템 동작을 측정하고 표시할 수 있는 방법을 가지고 있어야 한다. 
- 도구는 프로세스별 또는 시스템 전체의 관찰을 제공하는 것으로 특징지을 수 있다.
- 이러한 관찰을 위해 도구는 카운터 또는 추적의 두 가지 접근 방식 중 하나를 사용할 수 있다.

### 2.10.2.1 카운터 (Counters)
- 운영체제는 일련의 카운터를 통해 호출된 시스템 콜 횟수 또는 네트워크 장치 또는 디스크에 수행된 작업 수와 같은 시스템 활동을 추적.
- 다음은 카운터를 사용하는 Linux 도구의 예이다.

  #### 프로세스별
  - ps : 하나의 프로세스 또는 선택된 프로세스에 대한 정보를 보고한다.
  - top : 현재 프로세스에 대한 실시간 통계를 보고한다.

  #### 시스템 전체
  - vmstat : 메모리 사용량 통계를 보고한다.
  - netstat : 네트워크 인터페이스에 대한 통계를 보고한다.
  - iostat : 디스크의 I/O 사용량을 보고한다.
- Linux 시스템의 카운터 기반 도구 대부분은 /proc 파일 시스템에서 통계를 읽는다. 
- /proc은 커널 메모리에만 존재하는 "의사" 파일 시스템이며, 주로 다양한 프로세스별 통계와 커널 통계를 질이하는데 사용됨.
- /proc 파일 시스템은 디렉터리 계층 구조로 구성되며 프로세스 (각 프로세스에 지정된 고유한 정수값)가 /proc 아래의 하위 디렉터리로 표시됨.
- 예를 들어, 디렉터리 항목 /proc/2155에는 ID가 2155인 프로세스에 대한 프로세스별 통계가 포함된 다양한 커널 통계에 대한 /proc 항목 또한 표시됨.


- Windows 시스템은 Windows 작업 관리자를 제공하는데, 이 도구는 현재 실행 중인 응용 프로그램과 함께 프로세스, CPU, 메모리 사용 및 네트워크 통계를 보여준다.

## 2.10.3 추적 (Tracing)
- 카운터 기반 도구는 커널에서 유지 관리하는 특정 통계의 현재 값에 대해 간단히 문의하는 반면, 
- 추적 도구는 시스템 콜과 관련된 단계와 같은 특정 이벤트에 대한 데이터를 수집한다.


- 다음은 이벤트를 추적하는 Linux 도구의 예이다.
  #### 프로세스별
  - strace : 프로세스에 의해 호출된 시스템 콜을 추적한다.
  - gdb : 소스 레벨 디버거

  #### 시스템 전체
  - perf : 리눅스 성능 도구 모음
  - tcpdump : 네트워크 패킷을 수집

- 운영체제가 실행됨에 따라 이해, 디버그 및 조정을 더 쉽게 하는 것은 활발한 연구 및 실무 영역.
- 새로운 세대의 커널 지원 성능 분석 도구는 이 목표를 달성하는 방법을 크게 개선.
- 다음으로 Linux 에서 동적 커널 추적을 위한 툴킷인 BCC

## 2.10.4 BCC
- 사용자 수준과 커널 코드의 상호 작용을 디버깅하는 것은 양쪽의 코드를 이해하고 상호 작용을 계측할 수 있는 도구의 집합 없이는 거의 불가능.
- 그런 도구 집합이 정말로 유용하려면 디버깅을 염두에 두지 않고 작성된 부분을 포함한 시스템의 어느 부분도 디버깅할 수 있어야 하며 그 작업을 시스템의 안정성을 해치지 않고,
할 수 있어야 한다. 
- 이 도구 집합은 또한 성능에 미치는 영향을 최소로 해야 한다. 즉 이상적으로는 사용하지 않을 때는 성능에 전혀 영향을 주지 않고, 사용 중일때는 그에 비례하게 영향을 주어야 함.
- BCC 도구 집합은 이러한 요구 조건을 충족하면서 동적이고, 안전하며 낮은 영향력을 미치는 디버깅 환경을 제공.


- BCC (BPF Compiler Collection)는 Linux 시스템을 위한 추적 기능을 제공하는 풍부한 툴킷. 
- BCC는 eBPF (extended Berkeley Packet Filter) 도구에 대한 프런트엔드 인터페이스.
- BPF 기술은 컴퓨터 네트워크에서 트래픽을 필터링하기 위해 1990년대 초에 개발되었다. "확장된" BPF (eBPF)는 BPF에 다양한 기능을 추가하였다. 
- eBPF 프로그램은 C의 부분집합을 사용해 작성되며 eBPF 명령어로 컴파일되며, 이 명령어는 실행 중인 Linux 시스템에 동적으로 삽입될 수 있다.
- eBPF 명령어는 특정 이벤트 (예 : 호출된 특정 시스템 콜)를 캡처하거나 시스템 성능(예 : 디스크 I/O 수행에 필요한 시간)을 관찰하는 데 사용될 수 있다.
- eBPF 명령어가 올바르게 작동하는 것을 보장하기 위해 실행 중인 Linux 커널에 삽입하기 전에 검증기를 통과해야 한다. 
- 검증기는 명령어가 시스템 성능이나 보안에 영향을 미치지 않는지 확인한다.


- eBPF는 Linux 커널 내에서 추적할 수 있는 다양한 기능을 제공하지만 전통적으로 C 인터페이스를 사용하여 프로그램을 개발하는 것은 매우 어려웠다.
- BCC는 eBPF를 사용하는 도구를 더 쉽게 작성할 수 있도록 개발되었으며 Python 언어로 작성된 프론트엔드 인터페이스를 제공한다. 
- BCC 도구는 Python 으로 작성되며 eBPF 계측 기능과 인터페이스 하는 C 코드를 내장하며, 이어서 커널과 인터페이스한다.
- BCC 도구는 또한 C 프로그램을 eBPF 명령어로 컴파일하고, probe 또는 tracepoint를 사용하여 커널에 삽입한다. 
- Probe와 tracepoint는 Linux 커널에서 이벤트 추적을 허용하는 두 가지 기술이다.


- BCC 패키지는 실행 중인 Linux 커널에서 여러 활동 영역을 관찰하는 여러 기존 도구를 제공한다.
- 예를 들어, BCC disksnoop 도구는 디스크 I/O 작업을 추적한다. 다음 명령을 입력하면
```text
./disksnoop.py
```
- 아래와 같은 출력을 생성.
```text
TIME(s)            T       BYTES       LAT(ms)
1946.29186700      R       8           0.27
1946.33965000      R       8           0.26
1946.34585000      W       8192        0.96
1946.43251000      R       4096        0.56
1946.74121000      R       4096        0.36
```
- 이 출력은 I/O 작업이 발생한 시간, I/O가 읽기 또는 쓰기 작업인지 여부 및 I/O 관련된 바이트 수를 알려준다.
- 마지막 열은 지속 시간(지연 시간 또는 LAT로 표시됨)을 I/O의 밀리초 단위로 반영한다.


- BCC가 제공하는 많은 도구는 MySQL 데이터베이스, Java 및 Python 프로그램과 같은 특정 응용 프로그램에 사용할 수 있따.
- 특정 프로세스의 활동을 관찰하기 위해 probe를 배치할 수도 있다. 예를 들어
```text
./opensnoop -p 1225
```
- 식별자가 1225인 프로세스가 수행한 open() 시스템 콜만 추적한다.


- BCC를 특히 강력하게 만드는 것은 시스템에 해를 끼치지 않고 중요한 응용 프로그램을 실행하는 실제 프로덕션 시스템에서 해당 도구를 사용할 수 있다는 것이다.
- 이는 병목 현상이나 보안 악용 가능성을 식별하기 위해 시스템 성능을 관찰해야 하는 시스템 관리자에게 특히 유용하다.
- BCC는 새로운 기능이 지속해서 추가되면서 빠르게 변화하는 기술이다.


