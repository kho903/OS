# 2.2 사용자와 운영체제 인터페이스 (User and Operating-System Interface)
- 사용자가 운영체제와 접촉하는 방식에는 여러 방법이 있다. 여기서는 3가지 기본적인 방법에 대해 논의한다. 한 방식은 명령어 라인 인터페이스 또는 명령 인터프리터 (command interpret)를
제공하는 것이다. 이 명령어 라인 인터페이스는 사용자가 운영체제가 수행할 명령어를 직접 입력할 수 있도록 한다. 다른 두 가지는 사용자가 그래픽 기반 사용자 인터페이스를 통해 운영체제와
접촉하게 하는 것이다.

## 2.2.1 명령 인터프리터 (Command Interpreters)
- Linux, UNIX 및 Windows를 포함한 운영체제 대부분은 명령 인터프리터를 프로세스가 시작되거나 사용자가 (대화형 시스템상) 처음 로그온 할 때 수행되는 특수한 프로그램으로 취급. 선택할 수 
있는 여러 명령 인터프리터를 제공하는 시스템에서 이 해석기는 셸(shell)이라고 불린다. 예를 들면 UNIX나 Linux 시스템에서는 Bourne shell, C shell, Bourne-Again shell, Korn
shell 등을 포함하여 사용자가 선택할 수 있는 여러 셸이 제공된다. 협력업체 제공 셸 및 무료 사용자 작성 셸도 사용가능. 대부분의 셸은 유사한 기능을 제공하며, 사용자가 어느 셸을 사용할 
것인가는 개인 취향에 따라 달라진다.
- 명령 인터프리터의 주요 기능은 사용자 지정 명령을 가져와 실행하는 것이다. 이 수준에서 제공된 많은 명령은 파일을 조작한다. 즉, 생성, 삭제, 리스트, 프린트, 복사, 수행 등을 한다.
UNIX 시스템에서 사용 가능한 다양한 셸은 이런 방식으로 실행된다. 이 명령어들은 두 가지 일반적인 방법으로 구현될 수 있다.
- 한 가지 방법은 명령 인터프리터 자체가 명령을 실행할 코드를 가지는 경우이다. 예를 들면, 한 파일을 삭제하기 위한 명령은 명령 인터프리터가 자신의 코드의 한 부분으로 분기하고, 그 코드
부분이 매개 변수를 설정하고 적절한 시스템 콜을 한다. 이 경우 제공될 수 있는 명령의 수가 명령 인터프리터의 크기를 결정하는데, 그 이유는 각 명령이 자신의 구현 코드를 요구하기 때문이다.
- 여러 운영체제 중 UNIX에 의해 사용되는 대체 접근 방식은 시스템 프로그램에을 통해 대부분의 명령을 구현하는 것. 이 경우 명령 인터프리터는 전혀 그 명령을 알지 못한다. 단지 메모리에 
로드되어 실행될 파일을 식별하는 명령만 사용한다. 따라서 파일을 삭제하는 다음의 UNIX 명령 `rm file.txt`은 rm이라는 파일을 검색하고 파일을 메모리에 로드하고 file.txt로 수행한다.
rm 명령과 관련된 로직은 rm이라는 파일 내의 코드로 완전하게 정의된다. 이런 식으로 프로그래머는 적합한 프로그램 로직을 가진 새로운 파일을 생성함으로써 시스템에 새로운 명령을 쉽게 추가할 수
있다. 명령 인터프리터 프로그램은 이제 아주 작아질 수 있으며, 새로운 명령을 추가하기 위해 변경할 필요가 없다.

## 2.2.2 그래픽 기반 사용자 인터페이스 (Graphic User Interface)
- 운영체제와 접촉하는 두 번째 방식은 사용자 친화적인 그래픽 기반 사용자 인터페이스 또는 GUI를 통하는 방식이다. 이 방식에서는 명령어 라인 인터페이스를 통하여 사용자가 직접 명령어를 입력하는
것이 아니라, 데스크톱이라고 특징지어지는 마우스를 기반으로 하는 윈도 메뉴 시스템을 사용한다. 사용자는 마우스를 움직여 마우스 포인터를 프로그램, 파일, 시스템 기능 등을 나타내는 화면상의
이미지(아이콘)에 위치시킨다. 마우스의 포인터 위치에 따라, 마우스 버튼을 눌러 프로그램을 호출하거나 파일 혹은 디렉터리(폴더)를 선택할 수도 있고, 또는 명령을 포함한 메뉴를 풀다운할 수 있다.
- 그래픽 기반 사용자 인터페이스는 1970년대 초 Xerox PARC 연구 센터에서 수행된 연구의 일부로부터 기인한다. 최초의 GUI는 1973년 출시된 Xerox Alto 컴퓨터에 처음으로 등장. 그러나
그래픽 기반 인터페이스는 1980년대에 Apple Macintosh 컴퓨터에 의해 널리 사용되게 됨. Macintosh 운영체제의 사용자 인터페이스는 해가 흐르면서 많은 변화를 겪음. 가장 커다란 변화는
macOS에서 사용된 Aqua 인터페이스의 채용이다. Microsoft 사의 첫 번째 Windows (버전 1.0)는 MS-DOS의 GUI에 기본을 둔다. Windows 시스템의 이후 버전들은 모양과 기능 면에서
큰 발전을 한다.
- 전통적으로 UNIX 시스템은 명령어 라인 인터페이스가 주류를 이루었다. 그러나 K Desktop Environment(KDE) 및 GNU 프로젝트에 의한 GNOME 데스크톱과 같은 다양한 오픈 소스 프로젝트
등을 통해 디자인이 크게 향상된 다양한 GUI 인터페이스를 사용할 수 있다. KDE 및 GNOME 데스크톱은 Linux 및 다양한 UNIX 시스템에서 실행되며 오픈 소스 라이선스로 사용할 수 있다.
즉, 특정 라이선스 조건하에서 소스 코드를 읽고 수정하는 것이 쉽다는 것을 의미.

## 2.2.3 터치스크린 인터페이스 (Touch-Screen Interface)
- 대부분의 모바일 시스템에는 명령 라인 인터페이스나 마우스 및 키보드 시스템이 실용적이지 않기 때문에 스마트폰 및 휴대용 태블릿 컴퓨터는 일반적으로 터치스크린 인터페이스를 사용. 사용자는
터치스크린에서 손가락을 누르거나 스와이프 등의 제스처를 취하여 상호작용. 초기 스마트폰에는 물리적 키보드가 포함되어 있었지만, 이제 스마트폰과 태블릿의 대부분은 터치스크린에서 키보드를 
시뮬레이션한다. iPad와 iPhone 모두 Springboard 터치스크린 인터페이스를 사용.

## 2.2.4 인터페이스의 선택 (Choice of Interface)
- 명령어 라인 또는 그래픽 기반 인터페이스를 사용할 것인지는 개인의 취향. 컴퓨터를 관리하는 시스템 관리자와 시스템에 대해 깊게 알고 있는 파워 유저들은 명령어-라인 인터페이스를 사용.
그들에게는 하고자 하는 작업에 대해 더 빨리 접근할 수 있어서 명령어-라인 인터페이스가 더 효율적. 실제로 일부 시스템에서는 GUI를 통해서는 시스템 기능의 일부만을 이용할 수 있고, 자주 쓰이지
않는 나머지 기능은 명령어-라인을 사용할 수 있는 사용자만이 이용 가능. 게다가 명령어-라인 인터페이스는 보통 반복적으로 해야 하는 작업을 쉽게 할 수 있게 하는데, 프로그래밍이 가능하다는
사실이 한 몫을 차지한다.
- 예를 들어 자주 사용되는 작업이 명령어-라인의 여러 절차가 필요한 경우, 이 절차를 파일로 저장하고, 이 파일을 프로그램을 실행하는 것처럼 이용할 수 있다. 이러한 프로그램은 실행 가능한
기계어 코드로 컴파일 되지는 않지만 명령어-라인 인터페이스에 의해서 해석되면서 실행될 수 있다. 이러한 셸 스크립트 (shell scripts)는 UNIX와 Linux 같이 명령어-라인 인터페이스에 기반을 
둔 시스템에서는 매우 흔한 형태이다.
- 반면에 대부분의 Windows 사용자들은 Windows GUI 환경에서 작업하기를 원하며 셸 인터페이스는 거의 사용하지 않는다. 최신 버전의 Windows 운영체제는 데스크톱 및 일반 랩톱용 표준 
GUI와 태블릿용 터치스크린을 모두 제공. Macintosh 운영체제가 겪은 다양한 변화는 대조적인 면을 보여준다. 역사적으로 Mac OS는 GUI를 통해서만 운영체제와 상호 작용하게 하면서 명령어
라인 인터페이스를 제공하지 않았다. 그러나 부분적으로 UNIX 커널을 이용하여 구현된 macOS의 출시와 더불어 현재는 Aqua GUI와 명령어 라인 인터페이스를 함께 제공한다.
- iOS 및 Android 모바일 시스템에 명령어 라인 인터페이스를 제공하는 앱이 있지만 거의 사용되지 않는다. 대신, 거의 모든 모바일 시스템 사용자가 터치스크린 인터페이스를 사용하여
장치와 상호 작용한다.
- 사용자 인터페이스는 시스템마다 심지어 시스템 내에서 사용자마다 다를 수 있다. 그러나 통상 실제 시스템 구조에서는 제외되었다. 따라서 유용하고 친밀한 사용자 인터페이스를 설계하는 것이
운영체제의 직접적인 기능이 아니다. 운영체제의 관점에서, 우리는 사용자 프로그램과 시스템 프로그램을 구별하지 않는다.

