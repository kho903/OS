# 2.9 운영체제 빌딩과 부팅 (Building and Booting an Operating System)
- 하나의 특정 기기 구성에 맞게 운영체제를 설계, 코딩 및 구현할 수 있다. 그러나 보다 일반적으로 운영체제는 다양한 주변장치 구성을 가진 모든 종류의 컴퓨터에서 실행되도록 설계된다.

## 2.9.1 운영체제 생성 (Operating-System Generation)
- 가장 일반적으로 컴퓨터 시스템은 구매 시 운영체제가 이미 설치되어 있다. 예를 들어 Windows 또는 macOS가 사전 설치된 새 랩톱을 구입할 수 있다. 그러나 사전 설치된 운영 체제를 교체하거나
부가의 운영체제를 추가한다고 가정하자. 또는 운영체제가 없는 컴퓨터를 구입했다고 가정하자. 후자의 상황에서는 컴퓨터에 적절한 운영체제를 설치하고 사용할 수 있도록 구성할 수 있는 몇 가지
옵션이 있다.
- 운영체제를 처음부터 생성(또는 빌딩)하는 경우 다음 절차를 밟아야 한다.
1. 운영체제 소스 코드를 작성한다. (또는 이전에 작성된 소스 코드를 확보한다.)
2. 운영체제가 실행될 시스템의 운영체제를 구성한다.
3. 운영체제를 컴파일 한다.
4. 운영체제를 설치한다.
5. 컴퓨터와 새 운영체제를 부팅한다.
- 시스템을 구성하려면 어떤 기능이 포함되는지 명시해야 하며 이는 운영체제에 따라 다르다. 일반적으로 시스템 구성 방법을 설명하는 매개변수는 특정 유형의 구성 파일에 저장되며 이 파일을 만든 
후에는 여러 가지 방법으로 사용할 수 있다.
- 한편으로는 시스템 관리자가 이를 사용하여 운영체제 소스 코드의 사본을 수정할 수 있다. 그런 다음 운영체제가 완전히 컴파일된다(시스템 빌드라고 함). 컴파일시 주어진 데이터 선언, 초기화 및
상수는 구성 파일에 설명된 시스템에 맞는 운영체제의 출력-오브젝트 버전을 생성한다.
- 상세한 조정을 할 수 없는 수준에서는 시스템 설명을 통해 기존 라이브러리에서 사전 컴파일된 오브젝트 모듈을 선택할 수 있다. 이 모듈들이 서로 링크되어 새 운영체제가 생성된다. 이 과정을 통해
지원되는 모든 I/O 장치의 장치 드라이버를 포함한 라이브러리에서 필요한 것만 선택해 운영체제에 링크할 수 있다. 시스템이 다시 컴파일되지 않기 때문에 시스템 생성 속도는 빠르지만 생성 시스템은
지나치게 일반적일 수 있으며 다른 하드웨어 구성을 지원하지 않을 수 있다.
- 다른 극단적인 경우, 완전히 모듈 방식으로 시스템을 구성할 수 있다. 여기서 선택은 컴파일 또는 링크 시간이 아닌 실행 시간에 일어난다. 시스템 생성은 단순히 시스템 구성을 설명하는 매개변수를
설정하는 것이다.
- 이러한 접근 방식의 주요 차이점은 생성된 시스템의 크기 및 일반성과 하드웨어 구성이 변경될 때 변경이 얼마나 쉬운가에 있다. 임베디드 시스템의 경우 첫 번째 접근 방식을 채택하고 특정 정적
하드웨어 구성을 위한 운영체제를 생성하는 것은 드문 일이 아니다. 그러나 데스크톱 및 랩톱 컴퓨터와 모바일 장치를 지원하는 대부분의 최신 운영체제는 두 번째 접근 방식을 채택하였다. 즉,
운영체제는 여전히 특정 하드웨어 구성을 위해 생성되지만 적재가능 커널 모듈과 같은 기술을 사용하면 시스템의 동적 변경을 위한 모듈 방식을 지원할 수 있다.
- 이제 Linux 시스템을 처음부터 빌드하는 방법을 알아보자. 이러한 작업은 보통 다음과 같은 절차로 진행된다.
1. http://www.kernel.org 에서 Linux 소스 코드를 다운로드 한다.
2. "make menuconfig" 명령을 사용하여 커널을 구성한다. 이 단계는 .config 구성 파일을 생성한다.
3. "make" 명령을 사용하여 메인 커널을 컴파일한다. make 명령은 .config 파일에서 식별된 구성 매개변수를 기반으로 커널을 컴파일하여 커널 이미지인 vmlinuz 파일을 생성한다.
4. "make modules" 명령을 사용하여 커널 모듈을 컴파일한다. 커널 컴파일과 마찬가지로 모듈 컴파일은 .config 파일에 지정된 구성 매개변수에 따라 다르다.
5. "make modules install" 명령을 사용하여 커널 모듈을 vmlinuz 에 설치한다.
6. "make install" 명령을 입력하여 시스템에 새 커널을 설치한다.
- 시스템이 재부팅되면 이 새 운영체제가 실행되기 시작한다.
- 대안으로 Linux 가상 머신을 설치하여 기존 시스템을 수정할 수 있다. 그러면 호스트 운영체제(Windows 또는 macOS)가 Linux를 실행할 수 있다.
- Linux를 가상 머신으로 설치하기 위한 몇 가지 옵션이 있다. 한 가지 대안은 처음부터 가상 머신을 빌드하는 것이다. 이 옵션은 Linux 시스템을 처음부터 빌드하는 것과 유사. 그러나 운영체제는
컴파일될 필요가 없다. 또 다른 방법은 이미 빌드 및 구성된 운영체제인 Linux 가상 머신 어플라이언스를 이용하는 것이다. 이 옵션을 사용하려면 단순히 어플라이언스를 다운로드하고 VirtualBox
또는 VMware 같은 가상화 소프트웨어를 사용해 설치하면 된다. 예를 들어,
1. https://www.ubuntu.com/ 에서 Ubuntu ISO 이미지를 다운로드
2. 가상 머신 소프트웨어 VirtualBox 에 ISO를 부팅 가능한 매체로 사용하도록 지시하고 가상 머신 부팅
3. 설치 질문에 대답한 다음 운영체제를 가상 머신으로 설치하고 부팅

## 2.9.2 시스템 부트 (System Boot)
- 운영체제가 생성된 후에는 하드웨어에서 사용할 수 있어야 한다. 그러나 하드웨어는 커널의 위치 또는 커널을 적재하는 방법을 어떻게 알 수 있을까? 커널을 적재하여 컴퓨터를 시작하는 과정을
시스템 부팅이라고 한다. 시스템 대부분에서 부팅 과정은 다음과 같다.
1. 부트스트랩 프로그램 또는 부트 로더라고 불리는 작은 코드가 커널의 위치를 찾는다.
2. 커널이 메모리에 적재되고 시작된다.
3. 커널은 하드웨어를 초기화한다.
4. 루트 파일 시스템이 마운트 된다.
- 일부 컴퓨터 시스템은 다단계 부팅 과정을 사용한다. 컴퓨터 전원을 처음 켜면 BIOS라고 하는 비휘발성 펌웨어에 있는 소형 부트 로더가 실행된다. 이 초기 부트 로더는 일반적으로 부트 블록이라고
하는 디스크의 정해진 위치에 있는 두 번째 부트 로더를 적재하는 작업만 한다. 부트 블록에 저장된 프로그램은 전체 운영체제를 메모리에 적재하고 실행을 시작하기에 충분히 정교할 수도 있다. 더
일반적으로, 이 부트 로더는 간단한 코드로서 (하나의 디스크 블록에 저장되어야 하기 때문에) 디스크의 주소와 부트스트랩 프로그램 나머지의 길이만 알고 있따.
- 많은 최신 컴퓨터 시스템이 BIOS 기반 부팅 과정을 UEFI(Unified Extensible Firmware Interface)로 대체했다. UEFI는 64비트 시스템과 용량이 큰 디스크를 더 잘 지원하는 것을
포함해 BIOS에 비해 몇 가지 장점이 있따. 아마도 가장 큰 장점은 UEFI가 하나의 완전한 부팅 관리자이므로 다단계 BIOS 부팅 과정보다 빠르다는 것이다.
- 부트스트랩 프로그램은 BIOS에서 부팅하든 UEFI에서 부팅하든 다양한 작업을 수행할 수 있다. 커널 프로그램이 포함된 파일을 메모리에 로드하는 것 외에도 진단을 실시하여 메모리와 CPU를
점검하고 장치 검색과 같은 시스템 상태를 확인한다. 진단을 통과하면 프로그램은 부팅 단계를 계속 진행 가능. 부트스트랩은 CPU 레지스터에서 장치 컨트롤러 및 메인 메모리에 이르기까지 시스템의 
모든 측면을 초기화 가능. 조만간 운영체제를 시작하고 루트 파일 시스템을 마운트한다. 바로 이 시점에서 시스템이 실행 중이라고 말할 수 있다.
- GRUB은 Linux 및 UNIX 시스템을 위한 오픈 소스 부트스트랩 프로그램이다. 시스템의 부트 매개 변수는 GRUB 구성 파일에 설정되며 GRUB의 실행 시작 시점에 적재된다. GRUB는 융통성이
있어, 부팅 시 커널 매개 변수를 수정하거나 부팅 가능한 다른 커널 중 하나를 선택하는 것도 가능하다. 예를 드러, 다음은 특수 Linux 파일 `/proc/cmdline`에서 추출한 커널 매개 변수이며
이 파일은 부팅시 사용된다.
```text
BOOT_IMAGE=/boot/vmlinuz-4.4.0-59-generic
root=UUID=5f2e2232-4e47-4fe8-ae94-45ea749a5c92
```
- BOOT_IMAGE는 메모리에 적재될 커널 이미지의 이름, root는 루트 파일 시스템의 고유 식별자를 지정한다.
- 공간을 절약하고 부팅 시간을 줄이기 위해 Linux 커널 이미지는 압축 파일이며 메모리에 적재된 후 압축이 풀어진다. 부팅 과정에서 부트 로더는 일반적으로 initramfs로 알려진 임시 RAM
파일 시스템을 생성한다. 이 파일 시스템에는 실제 루트 파일 시스템(메인 메모리에 존재하지 않음)을 지원하기 위해 설치해야 하는 필수 드라이버와 커널 모듈이 저장되어 있따. 커널이 시작되고
필요한 드라이버가 설치되면 커널은 루트 파일 시스템을 임시 RAM 위치에서 적절한 루트 파일 시스템 위치로 전환한다. 
- 마지막으로 Linux는 시스템의 초기 프로세스인 systemd 프로세스를 생성한 다음 다른 서비스(웹 서버 또는 데이터베이스)를 시작. 궁극적으로 시스템은 사용자에게 로그인 프롬프트를 표시한다.
- 부트 메커니즘은 부트 로더와 독립적이지 않다. 따라서 BIOS와 UEFI용 특정 GRUB 부트 로더 버전이 있으며 펌웨어는 어떤 특정 부트 로더가 사용되는지 알아야 한다.
- 모바일 시스템의 부팅 과정은 기존 PC의 부팅 과정과 약간 다르다. 예를 들어, 커널은 Linux 기반이지만 Android는 GRUB을 사용하지 않고 대신 부트 로더의 제공을 벤더에게 맡긴다. 가장
일반적인 Android 부트 로더는 LK(little kernel, 작은 커널)이다. Android 시스템은 초기 RAM 파일 시스템뿐만 아니라 Linux와 동일한 압축 커널 이미지를 사용한다. 그러나 Linux는
필요한 드라이버가 모두 적재되면 initramfs를 폐기하지만 Android는 initramfs를 장치의 루트 파일 시스템으로 유지한다. 커널이 적재되고 루트 파일 시스템이 마운트 되면 Android는
init 프로세스를 시작하고 홈 화면을 표시하기 전에 여러 서비스를 생성한다.
- 마지막으로, Windows, Linux 및 macOS와 iOS 및 Android를 비롯한 대부분의 운영체제의 부트 로더는 하드웨어 문제 진단, 손상된 파일 시스템 복구 및 운영체제 재설치 등의 작업을 할
수 있는 복구 모드 또는 단일 사용자 모드로 부팅할 수 있는 기능을 제공한다. 하드웨어 장애 외에도 컴퓨터 시스템은 소프트웨어 오류 및 운영체제 성능 저하를 겪을 수 있다.

