# 2.3 시스템 콜 (System Calls)
- 시스템 콜은 운영체제에서 사용할 수 있는 서비스에 대한 인터페이스를 제공한다. 이러한 호출은 일반적으로 C/C++로 작성된 함수 형태로 사용할 수 있지만, 특정 저수준 작업 (예 : 하드웨어를
직접 접근해야 하는 작업)은 어셈블리 언어 명령을 사용하여 작성해야 할 수 있다.

## 2.3.1 예제 (Example)
- 운영체제가 어떻게 시스템 콜을 사용할 수 있게 만드는지에 대해 논의하기 전에 시스템 콜이 어떻게 사용되는지 예제를 살펴보자. 한 파일로부터 데이터를 읽어서 다른 파일로 복사하는 간단한
프로그램을 작성한다고 가정. 프로그램에 필요한 첫 번째 입력은 입력 파일과 출력 파일의 두 파일 이름이다. 이 이름들은 운영체제 설계에 따라 다양한 방법으로 지정 가능. 한 가지 방법은 명령의
일부로 두 파일의 이름을 전달하는 것이다. (예 : UNIX의 cp 명령)
```text
cp in.txt out.txt
```
- 이 명령은 입력 파일 in.txt를 출력 파일 out.txt에 복사한다. 두 번째 방법은 프로그램이 사용자에게 이름을 요청하는 것이다. 대화형 시스템에서 이 접근 방식은 일련의 시스템 콜이 필요하다.
먼저 화면에 프롬프트 메시지를 작성한 다음 키보드에서 두 파일의 이름을 지정하는 문자를 읽는디. 마우스 기반 및 아이콘 기반 시스템에서 파일 이름 메뉴는 일반적으로 창에 표시된다. 그런 다음
사용자는 마우스를 사용하여 소스 이름을 선택할 수 있으며 대상 이름을 지정할 수 있는 창을 열 수 있다. 이 일련의 작업을 위해서는 많은 I/O 시스템 콜이 필요하다.
- 일단 두 개의 파일 이름이 얻어지면, 프로그램은 반드시 입력 파일을 오픈하고 출력 파일을 생성하고 오픈한다. 각각의 이러한 연산은 또 다른 시스템 콜을 필요로 하며, 각 시스템 콜에서 오류가
발생하면 처리되어야 한다. 예를 들어, 프로그램이 입력 파일을 오픈하려고 할 때, 그 이름을 갖는 파일이 존재하지 않거나 그 파일에 대한 접근이 금지되어 있는 것을 발견할 수 있다. 이러한 경우,
프로그램은 에러 메시지를 출력하고(또 다른 일련의 시스템 콜), 그리고 비정상적으로 종료(또 다른 시스템 콜)한다. 만약 입력 파일이 존재하면 새로운 출력 파일을 생성해야 한다. 이러한 상황은
프로그램을 중단(abort)(하나의 시스템 콜)하거나, 기존 파일을 삭제(다른 시스템 콜)한 후, 새로운 파일을 생성(다른 시스템 콜)할 수도 있다. 대화형 시스템에서 또 다른 방법은 기존의 파일을
대체할 것인지, 혹은 프로그램을 중단할 것인지를 사용자에게 물어보는(프롬프트 메시지 출력과 터미널로부터 응답을 읽기 위한 일련의 시스템 콜) 것이다.
- 이제 두 개의 파일이 준비되면, 입력 파일로부터 읽어서(하나의 시스템 콜), 출력 파일에 기록(또 다른 시스템 콜)하는 루프에 들어가게 된다. 각 읽기와 쓰기는 가능한 여러가지 오류 상황의
정보를 반환해야 한다. 입력에서, 프로그램이 파일의 끝에 도달하거나 읽기 중에 하드웨어 오류(패리티 오류)가 발생할 수도 있다. 쓰기 연산 시 출력 장치에 따라 여러 가지 오류들(예: 디스크
공간의 부족)이 발생할 수도 있다.
- 마지막으로, 전체 파일이 복사된 후 프로그램은 두 파일을 모두 닫고 (두 개의 시스템 콜), 콘솔이나 윈도에 메시지를 기록하고 (추가의 시스템 콜), 결국 정상적으로 종료 (최종 시스템 콜)
하게 된다. 이러한 시스템 콜의 순서는 아래와 같다.
- 연속된 시스템 콜의 예
    - 입력 파일 이름 획득
      - 화면에 프롬프트 출력
      - 입력 받아들임
    - 출력 파일 이름 획득
      - 화면에 프롬프트 출력
      - 입력 받아들임
    - 입력 파일 열기
      - 파일 존재하지 않을 경우, 비정상적으로 종료
    - 출력 파일 생성
      - 파일이 존재할 경우, 비정상적으로 종료
    - 루프
      - 입력 파일로부터 읽어 들임
      - 출력 파일에 씀
    - 읽기가 실패할 때까지
    - 출력 파일 닫기
    - 화면에 완료 메시지 출력
    - 정상적으로 종료

## 2.3.2 응용 프로그래밍 인터페이스 (Application Programming Interface)
- 보다시피, 간단한 프로그램이라도 운영체제의 아주 많은 기능을 사용하게 된다. 종종 초당 수천 개의 시스템 콜을 수행한다. 사용자 대부분은, 이러한 정도의 상세를 결코 알지 못한다. 대부분의
응용 프로그래머는 응용 프로그래밍 인터페이스(application programming interface, API)에 따라 프로그램을 설계한다. API는 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할
수 있는 반환 값을 포함하여 응용 프로그래머가 사용 가능한 함수의 집합을 명시한다.
- 응용 프로그래머가 사용 가능한 가장 일반적인 API 3가지는 Windows API, POSIX 기반 시스템용 POSIX API(거의 모든 버전의 UNIX, Linux 및 Max OS X를 포함), Java 가상 머신에서
실행될 수 있는 프로그램을 위한 Java API이다. 프로그래머는 운영체제가 제공하는 코드의 라이브러리를 통해 API를 활용한다. UNIX와 Linux 시스템에서 C 언어로 작성된 프로그램을 위해서
제공되는 코드의 라이브러리를 통해 API를 활용한다. UNIX와 Linux 시스템에서 C언어로 작성된 프로그램을 위해서 제공되는 라이브러리는 libc로 불린다. 각 운영체제는 고유의 시스템 콜
이름을 가진다.
- 배후에서 API를 구성하는 함수들은 일반적으로 응용 프로그래머를 대신해 실제 시스템 콜을 호출한다. 예를 들면 Windows 함수 CreateProcess() (당연하게 새로운 프로세스를 생성하는 데
사용됨)는 실제로 Windows 커널에서 NTCreateProcess() 시스템 콜을 부른다.
- 왜 응용 프로그래머는 실제 시스템 콜을 호출하는 것보다 API에 따라 프로그래밍 하는 것을 선호할까? 그렇게 하는 데에는 몇 가지 이유가 있다. 첫 번째 이점은 프로그램의 호환성이다. API에
따라 프로그램을 설계하는 응용 프로그래머는 자신의 프로그램이 같은 API를 지원하는 어느 시스템에서건 컴파일되고 실행된다는 것을 기대할 수 있다. 게다가 실제 시스템 콜은 종종 좀 더 자세한
명세가 필요하고 프로그램상에서 작업하기가 API보다 어렵다. 그럼에도 불구하고 API 함수를 호출하는 것과 커널의 관련된 시스템 콜을 호출하는 것에는 강한 상관 관계가 존재한다. 사실 대부분의
POSIX와 Windows API는 UNIX, Linux 및 Windows 운영체제가 제공하는 고유의 시스템 콜과 유사하다.
- 시스템 콜을 처리하는 데 있어 중요한 또 다른 요소는 실행시간 환경(RTE, run-time environment)이다. 컴파일러 또는 인터프리터를 포함하여 특정 프로그래밍 언어로 작성된 응용 프로그램을
실행하는 데 필요한 전체 소프트웨어 제품군과 라이브러리 또는 로더와 같은 다른 소프트웨어를 함께 가리킨다. RTE는 운영체제가 제공하는 시스템 콜에 대한 연결고리 역할을 하는 시스템 콜 
인터페이스를 제공한다. 이 시스템 콜 인터페이스는 API 함수의 호출을 가로채어 필요한 운영체제 시스템 콜을 부른다. 일반적으로 각 시스템 콜에는 번호가 할당되고 시스템 콜 인터페이스는 이 번호에
따라 색인되는 테이블을 유지 관리한다. 시스템 콜 인터페이스는 의도하는 시스템 콜을 부르고 시스템 콜의 상태와 반환 값을 돌려준다.
- 호출자는 시스템 콜이 어떻게 구현되고 실행 중 무슨 작업을 하는지 아무것도 알 필요가 없다. 호출자는 단지 API를 준수하고 시스템 콜의 결과로서 운영체제가 무엇을 할 것인지만 이해하면 된다.
따라서 운영체제 인터페이스에 대한 재부분의 자세한 내용은 API에 의해 프로그래머부터 숨겨지고, RTE에 의해 관리된다.
- 시스템 콜은 사용되는 컴퓨터에 따라 다른 방법으로 발생한다. 종종, 단순히 원하는 시스템 콜이 무엇인지보다 더 많은 정보가 요구될 수 있다. 필요한 정보의 유형과 양은 특정 운영체제와 호출에
따라 다양하다. 예를 들면, 입력을 받아들이기 위해, 입력원(source)으로 사용될 파일이나 장치와 함께 읽어 들인 데이터를 저장할 메모리 버퍼의 주소와 길이를 명시할 필요가 있다. 물론 장치나
파일 그리고 길이는 시스템 콜에 암묵적(implicit)일 수 있다.
- 운영체제에 매개 변수를 전달하기 위해 세 가지 일반적인 방법을 사용. 가장 간단한 방법은 매개변수를 레지스터 내에 전달하는 것. 그러나 어떤 경우는 레지스터보다 더 많은 매개변수가 있을 수
있다. 이러한 경우에 매개변수는 메모리 내의 블록이나 테이블에 저장되고, 블록의 주소가 레지스터 내에 매개변수로 전달된다. Linux는 이러한 접근법을 조합하여 사용. 5개 이하의 매개변수가 있으면
레지스터가 사용된다. 매개 변수의 개수가 5개를 넘으면 블록 방법이 사용된다. 매개변수는 프로그램에 의해 스택(stack)에 넣어질(push) 수 있고, 운영체제에 의해 꺼내진다.(pop off). 일부 
운영체제는 블록이나 스택 방법을 선호하는데, 이들 접근법은 전달되는 매개변수들의 개수나 길이를 제한하지 않기 때문이다.

