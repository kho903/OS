# 2.3 시스템 콜 (System Calls)
- 시스템 콜은 운영체제에서 사용할 수 있는 서비스에 대한 인터페이스를 제공한다. 이러한 호출은 일반적으로 C/C++로 작성된 함수 형태로 사용할 수 있지만, 특정 저수준 작업 (예 : 하드웨어를
직접 접근해야 하는 작업)은 어셈블리 언어 명령을 사용하여 작성해야 할 수 있다.

## 2.3.1 예제 (Example)
- 운영체제가 어떻게 시스템 콜을 사용할 수 있게 만드는지에 대해 논의하기 전에 시스템 콜이 어떻게 사용되는지 예제를 살펴보자. 한 파일로부터 데이터를 읽어서 다른 파일로 복사하는 간단한
프로그램을 작성한다고 가정. 프로그램에 필요한 첫 번째 입력은 입력 파일과 출력 파일의 두 파일 이름이다. 이 이름들은 운영체제 설계에 따라 다양한 방법으로 지정 가능. 한 가지 방법은 명령의
일부로 두 파일의 이름을 전달하는 것이다. (예 : UNIX의 cp 명령)
```text
cp in.txt out.txt
```
- 이 명령은 입력 파일 in.txt를 출력 파일 out.txt에 복사한다. 두 번째 방법은 프로그램이 사용자에게 이름을 요청하는 것이다. 대화형 시스템에서 이 접근 방식은 일련의 시스템 콜이 필요하다.
먼저 화면에 프롬프트 메시지를 작성한 다음 키보드에서 두 파일의 이름을 지정하는 문자를 읽는디. 마우스 기반 및 아이콘 기반 시스템에서 파일 이름 메뉴는 일반적으로 창에 표시된다. 그런 다음
사용자는 마우스를 사용하여 소스 이름을 선택할 수 있으며 대상 이름을 지정할 수 있는 창을 열 수 있다. 이 일련의 작업을 위해서는 많은 I/O 시스템 콜이 필요하다.
- 일단 두 개의 파일 이름이 얻어지면, 프로그램은 반드시 입력 파일을 오픈하고 출력 파일을 생성하고 오픈한다. 각각의 이러한 연산은 또 다른 시스템 콜을 필요로 하며, 각 시스템 콜에서 오류가
발생하면 처리되어야 한다. 예를 들어, 프로그램이 입력 파일을 오픈하려고 할 때, 그 이름을 갖는 파일이 존재하지 않거나 그 파일에 대한 접근이 금지되어 있는 것을 발견할 수 있다. 이러한 경우,
프로그램은 에러 메시지를 출력하고(또 다른 일련의 시스템 콜), 그리고 비정상적으로 종료(또 다른 시스템 콜)한다. 만약 입력 파일이 존재하면 새로운 출력 파일을 생성해야 한다. 이러한 상황은
프로그램을 중단(abort)(하나의 시스템 콜)하거나, 기존 파일을 삭제(다른 시스템 콜)한 후, 새로운 파일을 생성(다른 시스템 콜)할 수도 있다. 대화형 시스템에서 또 다른 방법은 기존의 파일을
대체할 것인지, 혹은 프로그램을 중단할 것인지를 사용자에게 물어보는(프롬프트 메시지 출력과 터미널로부터 응답을 읽기 위한 일련의 시스템 콜) 것이다.
- 이제 두 개의 파일이 준비되면, 입력 파일로부터 읽어서(하나의 시스템 콜), 출력 파일에 기록(또 다른 시스템 콜)하는 루프에 들어가게 된다. 각 읽기와 쓰기는 가능한 여러가지 오류 상황의
정보를 반환해야 한다. 입력에서, 프로그램이 파일의 끝에 도달하거나 읽기 중에 하드웨어 오류(패리티 오류)가 발생할 수도 있다. 쓰기 연산 시 출력 장치에 따라 여러 가지 오류들(예: 디스크
공간의 부족)이 발생할 수도 있다.
- 마지막으로, 전체 파일이 복사된 후 프로그램은 두 파일을 모두 닫고 (두 개의 시스템 콜), 콘솔이나 윈도에 메시지를 기록하고 (추가의 시스템 콜), 결국 정상적으로 종료 (최종 시스템 콜)
하게 된다. 이러한 시스템 콜의 순서는 아래와 같다.
- 연속된 시스템 콜의 예
    - 입력 파일 이름 획득
      - 화면에 프롬프트 출력
      - 입력 받아들임
    - 출력 파일 이름 획득
      - 화면에 프롬프트 출력
      - 입력 받아들임
    - 입력 파일 열기
      - 파일 존재하지 않을 경우, 비정상적으로 종료
    - 출력 파일 생성
      - 파일이 존재할 경우, 비정상적으로 종료
    - 루프
      - 입력 파일로부터 읽어 들임
      - 출력 파일에 씀
    - 읽기가 실패할 때까지
    - 출력 파일 닫기
    - 화면에 완료 메시지 출력
    - 정상적으로 종료

## 2.3.2 응용 프로그래밍 인터페이스 (Application Programming Interface)
- 보다시피, 간단한 프로그램이라도 운영체제의 아주 많은 기능을 사용하게 된다. 종종 초당 수천 개의 시스템 콜을 수행한다. 사용자 대부분은, 이러한 정도의 상세를 결코 알지 못한다. 대부분의
응용 프로그래머는 응용 프로그래밍 인터페이스(application programming interface, API)에 따라 프로그램을 설계한다. API는 각 함수에 전달되어야 할 매개변수들과 프로그래머가 기대할
수 있는 반환 값을 포함하여 응용 프로그래머가 사용 가능한 함수의 집합을 명시한다.
- 응용 프로그래머가 사용 가능한 가장 일반적인 API 3가지는 Windows API, POSIX 기반 시스템용 POSIX API(거의 모든 버전의 UNIX, Linux 및 Max OS X를 포함), Java 가상 머신에서
실행될 수 있는 프로그램을 위한 Java API이다. 프로그래머는 운영체제가 제공하는 코드의 라이브러리를 통해 API를 활용한다. UNIX와 Linux 시스템에서 C 언어로 작성된 프로그램을 위해서
제공되는 코드의 라이브러리를 통해 API를 활용한다. UNIX와 Linux 시스템에서 C언어로 작성된 프로그램을 위해서 제공되는 라이브러리는 libc로 불린다. 각 운영체제는 고유의 시스템 콜
이름을 가진다.
- 배후에서 API를 구성하는 함수들은 일반적으로 응용 프로그래머를 대신해 실제 시스템 콜을 호출한다. 예를 들면 Windows 함수 CreateProcess() (당연하게 새로운 프로세스를 생성하는 데
사용됨)는 실제로 Windows 커널에서 NTCreateProcess() 시스템 콜을 부른다.
- 왜 응용 프로그래머는 실제 시스템 콜을 호출하는 것보다 API에 따라 프로그래밍 하는 것을 선호할까? 그렇게 하는 데에는 몇 가지 이유가 있다. 첫 번째 이점은 프로그램의 호환성이다. API에
따라 프로그램을 설계하는 응용 프로그래머는 자신의 프로그램이 같은 API를 지원하는 어느 시스템에서건 컴파일되고 실행된다는 것을 기대할 수 있다. 게다가 실제 시스템 콜은 종종 좀 더 자세한
명세가 필요하고 프로그램상에서 작업하기가 API보다 어렵다. 그럼에도 불구하고 API 함수를 호출하는 것과 커널의 관련된 시스템 콜을 호출하는 것에는 강한 상관 관계가 존재한다. 사실 대부분의
POSIX와 Windows API는 UNIX, Linux 및 Windows 운영체제가 제공하는 고유의 시스템 콜과 유사하다.
- 시스템 콜을 처리하는 데 있어 중요한 또 다른 요소는 실행시간 환경(RTE, run-time environment)이다. 컴파일러 또는 인터프리터를 포함하여 특정 프로그래밍 언어로 작성된 응용 프로그램을
실행하는 데 필요한 전체 소프트웨어 제품군과 라이브러리 또는 로더와 같은 다른 소프트웨어를 함께 가리킨다. RTE는 운영체제가 제공하는 시스템 콜에 대한 연결고리 역할을 하는 시스템 콜 
인터페이스를 제공한다. 이 시스템 콜 인터페이스는 API 함수의 호출을 가로채어 필요한 운영체제 시스템 콜을 부른다. 일반적으로 각 시스템 콜에는 번호가 할당되고 시스템 콜 인터페이스는 이 번호에
따라 색인되는 테이블을 유지 관리한다. 시스템 콜 인터페이스는 의도하는 시스템 콜을 부르고 시스템 콜의 상태와 반환 값을 돌려준다.
- 호출자는 시스템 콜이 어떻게 구현되고 실행 중 무슨 작업을 하는지 아무것도 알 필요가 없다. 호출자는 단지 API를 준수하고 시스템 콜의 결과로서 운영체제가 무엇을 할 것인지만 이해하면 된다.
따라서 운영체제 인터페이스에 대한 재부분의 자세한 내용은 API에 의해 프로그래머부터 숨겨지고, RTE에 의해 관리된다.
- 시스템 콜은 사용되는 컴퓨터에 따라 다른 방법으로 발생한다. 종종, 단순히 원하는 시스템 콜이 무엇인지보다 더 많은 정보가 요구될 수 있다. 필요한 정보의 유형과 양은 특정 운영체제와 호출에
따라 다양하다. 예를 들면, 입력을 받아들이기 위해, 입력원(source)으로 사용될 파일이나 장치와 함께 읽어 들인 데이터를 저장할 메모리 버퍼의 주소와 길이를 명시할 필요가 있다. 물론 장치나
파일 그리고 길이는 시스템 콜에 암묵적(implicit)일 수 있다.
- 운영체제에 매개 변수를 전달하기 위해 세 가지 일반적인 방법을 사용. 가장 간단한 방법은 매개변수를 레지스터 내에 전달하는 것. 그러나 어떤 경우는 레지스터보다 더 많은 매개변수가 있을 수
있다. 이러한 경우에 매개변수는 메모리 내의 블록이나 테이블에 저장되고, 블록의 주소가 레지스터 내에 매개변수로 전달된다. Linux는 이러한 접근법을 조합하여 사용. 5개 이하의 매개변수가 있으면
레지스터가 사용된다. 매개 변수의 개수가 5개를 넘으면 블록 방법이 사용된다. 매개변수는 프로그램에 의해 스택(stack)에 넣어질(push) 수 있고, 운영체제에 의해 꺼내진다.(pop off). 일부 
운영체제는 블록이나 스택 방법을 선호하는데, 이들 접근법은 전달되는 매개변수들의 개수나 길이를 제한하지 않기 때문이다.

## 2.3.3 시스템 콜의 유형 (Types of System Calls)
- 시스템 콜은 여섯 가지의 주요 범주, 즉, 프로세스 제어, 파일 조작, 장치 조작, 정보 유지 보수와 통신과 보호 등으로 묶을 수 있다. 이후 운영체제에 의해 제공되는 여러 가지 유형의 시스템 콜
논의. 시스템 콜의 유형의 요약은 다음과 같다.

### 시스템 콜의 유형 요약
- 프로세스 제어 (Process Control)
  - 끝내기(end), 중지(abort)
  - 적재(load), 수행(execute)
  - 프로세스 생성, 종료
  - 프로세스 속성(attributes) 획득, 설정
  - 시간을 기다림
  - 이벤트를 기다림(wait event), 이벤트를 알림(signal event)
  - 메모리 할당 및 자유화
- 파일 조작 (File Manipulation)
  - 파일 생성(create file), 파일 삭제(delete file)
  - 열기(open), 닫기(close)
  - 읽기, 쓰기, 위치 변경(reposition)
  - 파일 속성 획득 및 설정
- 장치 관리(Device Management)
  - 장치를 요구(request devices), 장치를 방출 (release devices)
  - 읽기 쓰기, 위치 변경(reposition)
  - 장치 속성 획득, 장치 속성 설정
  - 장치의 논리적 부착(attach), 또는 분리(detach)
- 정보 유지(Information Maintenance)
  - 시간과 날짜의 설정과 획득
  - 시스템 데이터의 설정과 획득
  - 프로세스, 파일, 장치 속성의 획득
  - 프로세스, 파일, 장치 속성의 설정
- 통신(Communication)
  - 톤신 연결의 생성, 제거
  - 메시지의 송신, 수신
  - 상태 정보 전달
  - 원격 장치의 부착(attach) 및 분리 (detach)
- 보호(Protection)
  - get file permissions
  - set file permissions

### 2.3.3.1 프로세스 제어 (Process Control)
- 실행 중인 프로그램은 수행을 정상적으로(end()) 또는 비정상적으로(abort()) 멈출 수 있어야 한다. 현재 실행 중인 프로그램을 비정상적으로 중지하기 위해 시스템 콜이 호출되거나 프로그램에
문제가 발생해 오류 트랩(trap)을 유발할 경우, 때때로 메모리 덤프가 행해지고 오류 메시지가 생성된다. 이 덤프는 특별한 로그 파일이나 디스크에 기록되고 문제의 원인을 확인하기 위해 디버거
(버그를 찾고 수정하는 데 도움을 주는 시스템 프로그램)에 의해 검사될 수 있다. 정상이거나 비정상인 상황에서, 운영체제는 명령 인터프리터로 제어를 전달해야 한다. 명령 인터프리터는 이어 다음
명령을 읽는다. 대화식 시스템에서 명령 인터프리터는 단순히 다음 명령을 계속 수행하여 사용자가 오류에 응답하는 적절한 명령을 내릴 것을 가정한다. GUI 시스템에서는 팝업 윈도가 사용자에게
오류를 알리고 지시를 기다린다. 일부 시스템에서는 오류가 발생할 경우 특별한 복구 행위를 지시하는 제어 카드를 허용한다. 만약 프로그램이 입력에서 오류를 발견한고 비정상으로 종료를 원하면, 
프로그램은 오류 수준을 정의하기를 원할 수 있다. 더 높은 등급의 오류는 오류 매개 변수를 전달함으로써 더 치명적인 오류를 나타낼 수 있다. 이렇게 하면 정상 종료를 등급 0의 오류로 정의해
정상 종료와 비정상 종료를 결합 가능. 명령 인터프리터, 혹은 다음 프로그램은 이 오류 등급을 사용하여 다음 행동을 자동으로 결정할 수 있다.
- 한 프로그램을 실행하는 프로세스는 다른 프로그램을 적재(load())하고 실행(execute())하기를 원할 수 있다. 이 기능은 명령 인터프리터가 사용자 명령 또는 마우스의 클릭(click)을 통해
지시된 프로그램 실행을 허용한다. 여기서 흥미로운 질문은 적재된 프로그램이 종료될 때 어디로 제어를 되돌려 주느냐 하는 것. 이 질문은 기존 프로그램이 유실될지, 보관될지, 새로운 프로그램과
병행하게 실행을 계속하도록 허용할 것인지 하는 문제와 관련있다.
- 만약 새로운 프로그램이 종료되었을 떄 제어가 기존 프로그램으로 돌아간다면, 우리는 반드시 기존 프로그램 메모리 이미지를 보관해야 한다. 따라서 우리는 실질적으로 한 프로그램이 다른 
프로그램을 호출하는 기법을 만든 셈이다. 만약 두 프로그램이 병행하게 수행된다면, 우리는 다중 프로그래밍 될 새로운 프로세스를 생성한 것이다. 종종 이런 특정 목적을 위한 시스템 콜이
있다. (create_process())
- 만약 새로운 잡이나 프로세스, 혹은 잡들이나 프로세스들의 집합을 생성한다면, 우리는 그들의 실행을 제어할 수 있어야 한다. 이러한 제어는 잡의 우선순위, 최대 허용 실행 시간 등을 포함하여 
잡 혹은 프로세스의 속성들을 결정하고 재설정(reset)할 수 있는 능력이 필요하다 (get_process_attributes() 및 set_process_attributes()). 우리는 또한 새로 생성한 잡이나
프로세스가 잘못되었거나 더 이상 필요 없다면 종료하기를 원할 수 있다. (terminate_process())
- 새로운 프로세스를 생성한 후에는 이들의 실행이 끝나기를 기다려야 할 필요가 있을 수 있다. 일정 시간만큼 기다리기를 원할 수 있다(wait_time()). 그리고 더욱 가능성이 큰 경우는 특정
이벤트가 일어날 때까지 기다리는 것이다(wait_event()). 그 경우 프로세스들은 그 이벤트가 일어나면 신호를 보내야 한다(signal_event()).
- 빈번하게 둘 이상의 프로세스들은 데이터를 공유. 공유되는 데이터의 일관성을 보장하기 위해 운영체제는 종종 프로세스가 공유 데이터를 잠글 수 있는 시스템 콜을 제공. 그러면 잠금이 해제될
때까지 어느 프로세스도 데이터에 접근할 수 없게 된다. 일반적으로 그런 시스템은 acquire_lock()과 release_lock() 시스템 콜을 제공한다. 즉, 병행 프로세스들의 조정(coordination)을
처리하는 이런 유형의 시스템 콜이 존재한다.
- 프로세스 제어는 너무 많은 측면과 다양성이 있어 이러한 개념들을 명확히 하기 위해 단일 태스킹 시스템과 다중 태스킹 시스템 두 예를 보자. Arduino는 마이크로 컨트롤러와 다양한 이벤트에
반응하는 입력 센서로 구성된 간단한 하드웨어 플랫폼이다. Arduino가 반응하는 이벤트는 빛, 온도, 기압 등이다. Arduino 응용 프로그램을 작성하려면 먼저 PC에서 프로그램을 작성한 다음
USB 연결로 컴파일된 프로그램(스케치)을 PC에서 Arduino 플래시 메모리로 업로드한다. 표준 Arduino 플랫폼은 운영체제를 제공하지 않는다. 대신 부트 로더로 불리는 작은 소프트웨어가
스케치를 Arduino 메모리의 특정 영역에 로드한다. 스케치가 로드되면 실행되기 시작하고 반응하도록 프로그램된 이벤트를 기다린다. 예를 들어, Arduino의 온도 센서가 측정 온도가 특정 
임계값을 초과했음을 감지하면 스케치는 Arduino가 팬의 모터를 작동시키게 만들 수 있다. Arduino는 한순간에 하나의 스케치만 메모리에 존재할 수 있으므로 단일 태스킹 시스템으로 간주된다.
다른 스케치가 로드되면 기존 스케치를 대체한다. 또한 Arduino는 하드웨어 입력 센서 이외의 사용자 인터페이스를 제공하지 않는다.
- FreeBSD(Berkeley UNIX로부터 비롯됨)는 다중 태스킹 시스템의 예이다. 사용자가 시스템에 로그인할 때 사용자가 선택한 셸이 수행되어 명령을 기다렸다가 사용자가 요청한 프로그램을 
수행한다. 그렇지만 FreeBSD는 다중 태스킹 시스템이기 때문에 명령 인터프리터는 다른 프로그램이 실행되는 동안 수행을 계속 가능. 새로운 프로세스를 시작하기 위해 셸은 fork() 시스템 콜을
실행. 그런 다음, 선택된 프로그램이 exec() 시스템 콜은 통해 메모리에 적재되고, 이어 그 프로그램이 수행된다. 명령이 내려진 방법에 따라, 셸은 프로세스가 종료하기를 기다리거나
"백그라운드"에서 프로세스를 수행한다. 후자의 경우 셸은 즉시 다른 명령이 입력되기를 기다린다. 프로세스가 백그라운드에서 수행될 때, 그 프로세스는 키보드로부터 직접 입력을 받을 수 없는데,
이는 셸이 그 자원을 사용하고 있기 때문이다. 따라서 입출력은 파일, 또는 GUI 인터페이스를 통해 행해진다. 반면 사용자는 셸에게 다른 프로그램을 수행하도록 요청하거나, 수행 중인 프로세스의
진행 상황을 감시하게 하거나, 그 프로그램의 우선순위를 변경하는 등의 요청을 자유롭게 할 수 있다. 프로세스가 끝나면, 종료하기 위해 exit() 시스템 콜을 수행하며, 호출한 프로세스에게 
상태 코드 0을 돌려주거나 0이 아닌 오류 코드를 돌려준다. 이러한 상태 또는 오류 코드는 셸 또는 다른 프로그램들이 이용할 수 잇게 된다.

### 2.3.3.2 파일 관리 (File Management)
- 먼저 파일을 생성(create())하고 삭제(delete())할 수 있어야 한다. 이들 시스템 콜은 파일 이름이나 파일 속성의 일부를 요구한다. 파일이 생성되면 그것을 열고(open()) 사용해야 한다.
- 또한 읽고(read()), 쓰고(write()), 위치 변경(reposition()), 예를 들면, 되감기(rewind())나 파일의 끝으로 건너뛰기할 수 있다. 마지막으로 파일을 더 이상 사용하지 않음을
나타내는 파일 닫기(close())가 필요하다.
- 파일 시스템이 파일을 조직하기 위해 디렉터리 구조를 가진다면, 우리는 디렉터리에 대해서도 이와 같은 연산 집합이 필요할 것이다. 추가로, 파일이나 디렉터리에 대해 여러 속성의 값을 결정할 수
있어야 하고, 필요하다면, 그것을 재설정(reset)할 수 있어야 한다. 파일 속성은 파일 이름, 파일 유형, 보호 코드, 계정 정보 등을 포함한다. 이러한 기능을 위해서는 최소한 파일 속성 획득
(get_file_attribute())과 파일 속성 설정(set_file_attribute())의 두 시스템 콜이 필요하다. 몇몇 운영체제는 파일 이동(move())와 복사(copy()) 등의 훨씬 더 많은 시스템 콜을 
제공. 일부 시스템들은 코드와 다른 시스템 콜을 이용해 동일한 작업을 수행하는 API를 제공할 수도 있고 일부 시스템은 단순히 동일한 작업을 수행하는 시스템 프로그램을 제공하기도 한다. 만일 이
시스템 프로그램이 다른 프로그램에 의해 호출 가능하다면 다른 프로그램의 입장에서는 이 시스템 프로그램이 API가 된다.

### 2.3.3.3 장치 관리 (Device Management)
- 프로세스는 작업을 계속 수행하기 위해 추가 자원이 필요할 수 있다. 이러한 추가 자원은 주 기억장치, 디스크 드라이브, 파일에의 접근 등이 될 수 있다. 만약 자원들을 사용할 수 있다면,
이들 자원이 주어지고, 제어가 사용자 프로그램으로 복귀될 수 있다. 그렇지 않으면, 프로그램은 충분한 자원이 사용 가능하게 될 때까지 기다려야 한다.
- 운영체제에서 제어하는 다양한 자원들은 장치고 간주될 수 있다. 이 장치들의 일부는 물리 장치(예 : 디스크 드라이브)이고 다른 장치들은 추상적 혹은, 가상적 장치로 생각할 수 있다 (예 :
파일). 다수의 사용자가 동시에 사용하는 시스템은 독점적인 장치 사용을 보장받기 위해 그 장치를 요청(request())하는 것을 요구한다. 그 장치의 사용이 끝나면, 우리는 그것을 반드시
방출(release())해야 한다. 이러한 기능은 파일의 열기, 닫기(open(), close()) 시스템 콜과 비슷하다. 다른 운영체제들은 장치에 대해 통제되지 않은 접근을 허용한다. 예상되는 위험은
장치에 대한 잠재적 경합 및 교착 상태이다.
- 일단 장치를 요청하고 할당 받으면 파일과 마찬가지로 그 장치를 읽고(read()), 쓰고(write()), 그리고(아마도) 재배치 (reposition()) 할 수 있다. 실제로 입출력 장치와 파일간에는
유사성이 매우 많기 때문에, UNIX를 포함한 많은 운영체제가 이들 둘을 통합된 파일-장치 구조(file device structure)로 결합하였다. 이 경우 같은 시스템 콜이 파일과 장치에 대해
사용된다. 때로 입출력 장치들은 특별한 파일 이름, 디렉터리 배치 또는 파일 속성으로 식별된다.
- 사용자 인터페이스는 기본 시스템 콜이 유사하지 않더라도 파일과 장치를 유사하게 보이게 할 수도 있다. 이것은 운영체제 및 사용자 인터페이스를 구축하는 데 많은 설계 결정 사항 중의 한 예.

### 2.3.3.4 정보 유지 관리 (Information Maintenance)
- 많은 시스템 콜은 단순히 사용자 프로그램과 운영체제 간의 정보 전달을 위해 존재한다. 예를 들면, 시스템 대부분은 현재 시간 (time())과 날짜를 되돌려 주는 (date()) 시스템 콜을
가지고 있다. 다른 시스템 콜은 운영체제의 버전 번호, 사용 가능한 메모리 또는 디스크 공간의 양 등과 같은 시스템에 대한 정보를 반환할 수 있다.
- 다른 시스템 콜 집합은 프로그램 디버깅에 도움이 된다. 많은 시스템이 메모리를 덤프(dump())하기 위한 시스템 콜을 제공. 이 조항은 디버깅에 유용. Linux 시스템에서 사용 가능한 프로그램
strace는 실행될 때마다 각 시스템 콜을 나열한다. 마이크로프로세서조차도 한 명령어 실행(single step)이라고 하는 CPU 모드를 제공하며, 이 모드에서 모든 명령어 실행 후에 트랩이 CPU에
의해 실행된다. 트랩은 일반적으로 디버거에 의해 포착된다.
- 많은 운영체제는 프로그램의 시간 프로파일(time profile)을 제공한다. 시간 프로파일은 그 프로그램이 특정 위치, 혹은 위치의 집합에서 수행한 시간의 양을 나타낸다. 시간 프로파일은
추적 설비(tracing facility)나 정규 타이머 인터럽트가 필요하다. 타이머 인터럽트가 발생할 때마다, 프로그램 카운터의 값이 기록된다. 따라ㅓㅅ 타이머 인터럽트가 충분히 빈번하게 일어나면,
프로그램의 여러 부분에서 소비한 시간의 통계적 그림을 얻을 수 있다.
- 또한 운영체제는 모든 프로세스에 대한 정보를 유지하고 시스템 콜을 사용하여 이 정보에 접근한다. 일반적으로, 그 프로세스 정보를 획득하고 설정하기 위한 시스템 콜도 있다.
  (get_process_attributes(), set_process_attributes())

### 2.3.3.5 통신 (Communication)
- 프로세스 간 통신에는 메시지 전달 모델과 겅유 메모리 모델의 두 가지 일반적인 모델이 있다.
- 메시지 전달 모델에서는 통신하는 두 프로세스가 정보를 교환하기 위해 서로 메시지를 주고받는다. 메시지는 두 프로세스 사이에 직접 교환되거나 우편함을 통해 간접적으로 교환될 수 있다. 통신이
이루어지기 전에 연결이 반드시 열려야 한다. 상대 통신자(communicator)가 동일한 CPU에 있는 프로세스이든지 통신 네트워크에 의해 연결된 다른 컴퓨터에 있는 프로세스이든지 간에 그 이름을
반드시 알고 있어야 한다. 네트워크의 각 컴퓨터는 호스트 이름을 가지며, 각 컴퓨터는 이들 이름으로 일반적으로 알려져 잇다. 마찬가지로 각 프로세스는 프로세스 이름을 가지고 있으며, 이 이름은
운영체제에 의해 동등한 식별자로 변환되고, 이 식별자는 운영체제가 그 프로세스를 가리키는 데 사용할 수 있다. get_hostid()와 get_processid() 시스템 콜은 이러한 변호나을 수행한다.
- 이 식별자는 시스템의 통신 모델에 따라 파일 시스템에 의해 제공되는 범용 open, close 호출에 전달되거나, 특정 open_connection()과 close_connection() 시스템 콜에 전달된다.
수신 프로세스는 일반적으로 통신이 일어날 수 있도록 accept_connection() 호출에 자신의 허가(permission)를 제공한다. 
- 연결을 받아들일 프로세스들의 대부분은 디먼(daemon)으로서, 이들은 그러한 목적을 위해 제공된 시스템 프로그램들이다. 그들은 연결을 위해 대기(wait_for_connection()) 호출을 수행하고
연결이 이루어질 때 깨어난다. 클라이언트(client)로 알려진 통신의 출발지와 서버(server)로 알려진 수신 디먼은 이어 read_message()와 write_message() 시스템 콜에 의해 메시지들을
교환한다. close_connection() 호출은 통신을 종료한다.
- 공유 메모리 모델에서 프로세스는 다른 프로세스가 소유한 메모리 영역에 대한 접근을 위해 shared_memory_create()와 shared_memory_attach() 시스템 콜을 사용. 정상적으로
운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근하는 것을 막으려고 한다. 공유 메모리는 두 개 이상의 프로세스가 이러한 제한을 제거하는 데 동의할 것을 필요로 한다.
- 그런 다음 공유 영역에서 데이터를 읽고 쓰는 방식으로 정보를 교환할 수 있다. 데이터의 형식은 운영체제의 제어하에 있는 것이 아니라 이들 프로세스에 의해 결정된다. 프로세스는 또한 동일한
위치에 동시에 쓰지 않도록 보장할 책임을 진다. 또한 프로세스 모델의 변형으로 디폴트로 메모리를 공유하는 스레드도 존재한다.
- 메시지 전달 모델, 공유 메모리 모델, 두 가지 방법은 운영체제에서 보편적이며, 시스템 대부분은 둘 다 구현한다. 메시지 전달은 소량의 데이터를 교환할 때 유용. 이는 피해야 할 충돌이 없기
때문이다. 메시지 전달은 또한 컴퓨터 간의 통신을 위해 메모리 공유보다 구현하기가 쉽다. 공유 메모리는 한 컴퓨터 안에서는 메모리 전송 속도로 수행할 수 있으므로 최대 속도와 편리한 통신을
허용한다. 그렇지만, 보호와 동기화 부분에서 여러 문제점을 가지고 있다.

### 2.3.3.6 보호 (Protection)
- 보호는 컴퓨터 시스템이 제공하는 자원에 대한 접근을 제어하기 위한 기법을 지원한다. 역사적으로 보호는 다수의 사용자를 가지는 다중 프로그램 시스템에서만 고려되는 문제였다. 그러나 네트워킹과
인터넷의 출현으로 서버에서 휴대용 컴퓨터까지 모든 컴퓨터 시스템에서 보호를 고려하여야 한다.
- 일반적으로 보호를 제공하는 시스템 콜은 set_permission()과 get_permission()을 포함하는데, 파일과 디스크와 같은 자원의 허가 권한을 설정하는 데 이용된다. allow_user()와
deny_user() 시스템 콜은 특정 사용자가 지정된 자원에 대해 접근이 허가 혹은 불허되었는지를 명시.

