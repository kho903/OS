# 2.8 운영체제 구조 (Operating-System Structures)
- 현대의 운영체제와 같이 크고 복잡한 시스템은 적절하게 동작하고 쉽게 변경될 수 있으려면 신중히 제작되어야 한다. 일반적인 접근 방식은 단일 시스템보다는 태스크의 크기를 작은 구성
요소로 분할하는 것이다. 이러한 각 모듈은 신중하게 정의된 인터페이스 및 기능과 함께 시스템의 잘 정의된 부분이어야 한다. 프로그램을 구성할 때 비슷한 접근 방식을 사용할 수 있다.
main() 함수에 모든 코드를 배치한ㄴ 대신 로직을 여러 함수로 분리하고 매개 변수와 반환 값을 명확하게 표현한 다음 main() 함수에서 해당 함수를 호출한다.
- 이 절에서는 이러한 구성 요소들이 어떤 방법으로 상호 연결되고 하나의 커널로 결합되는지 알아본다.

## 2.8.1 모놀리식 구조 (Monolithic Structure)
- 운영체제를 구성하는 가장 간단한 구조는 구조가 전혀 없는 것이다. 즉, 커널의 모든 기능을 단일 주소 공간에서 실행되는 단일 정적 이진 파일에 넣는 것이다. 모놀리식 구조라고 하는
이 방법은 운영체제를 설계하는 일반적인 기술이다.
- 제한적인 구조를 가진 운영체제의 예는 최초의 UNIX 운영체제로 커널과 시스템 프로그램의 두 부분으로 구성된다. 커널은 여러 가지 인터페이스와 장치 드라이버로 다시 분리되는데,
이들은 UNIX가 발전해 오면서 수년 동안 추가되고 확장된 것이다. 기존 UNIX 운영체제는 계층들로 이루어져 있다. 시스템 콜 인터페이스 아래와 물리적 하드웨어 위에 있는 모든 것이
커널이다. 커널은 시스템 콜을 통해 파일 시스템, CPU 스케줄링, 메모리 관리 그리고 다른 운영체제 기능을 제공한다. 요약하면, 그것은 하나의 주소 공간으로 결합하기에는 엄청나게
많은 기능이다.
- Linux 운영체제는 UNIX에 기반을 두고 있으며, 응용 프로그램은 일반적으로 커널에 대한 시스템 콜 인터페이스와 통신할 때 glibc 표준 C 라이브러리를 사용한다. Linux 커널은
단일 주소 공간에서 커널 모드로 전부 식행된다는 점에서 모놀리식이지만, 런타임 중에 커널을 수정할 수 있는 모듈식 설계를 갖추고 있다.
- 모놀리식 커널의 명백한 단순성에도 불구하고, 이 구조는 구현 및 확장이 어렵다. 그러나 모놀리식 커널은 성능 면에서 뚜렷한 이점이 있다. 시스템 콜 인터페이스에는 오버헤드가 거의
없고, 커널 내 통신 속도가 빠르다. 따라서 모놀리식 커널의 단점에도 불구하고, 속도와 효율성은 이 구조의 증거를 여전히 UNIX, Linux 및 Windows 운영체제에서 발견할 수 있는
이유를 설명한다.

## 2.8.2 계층적 접근 (Layered Approach)
- 모놀리식 접근법은 시스템의 한 부분을 변경하면 다른 부분에 광범위한 영향을 미칠 수 있기 때문에 종종 밀접하게 결합된 시스템으로 불린다. 대안으로 느슨하게 결합된 시스템을 설계할
수 있다. 이러한 시스템은 특정 기능 및 한정된 기능을 가진 개별적이며 작은 구성 요소로 나뉜다. 이 모든 구성 요소가 합쳐져 커널을 구성한다. 이 모듈 방식의 장점은 한 구성 요소의
변경이 해당 구성 요소에만 영향을 미치고 다른 구성 요소에는 영향을 미치지 않으므로 시스템 구현자가 시스템의 내부 작동을 더 자유롭게 생성하고 변경할 수 있다는 점이다.
- 시스템은 다양한 방식으로 모듈화가 될 수 있다. 한 가지 방식이 계층적 접근 방식인데 이 방식에서는 운영체제가 여러 개의 층(계층)으로 나누어진다. 최하위 층(층 0) 하드웨어이고
최상위 층(층 N)은 사용자 인터페이스이다.
- 운영체제 층은 데이터와 이를 조작하는 연산으로 구성된 추상된 객체의 구현이다. 전형적인 운영체제 층(편의상 M층)은 자료구조와 상위층에서 호출할 수 있는 루틴의 집합으로 구성된다.
층 M은 단지 다시 하위층 하위층들의 서비스와 기능(연산)들만을 사용하도록 선택된다. 층 M은 다시 하위층에 대한 연산을 호출할 수 이싿.
- 계층적 접근 방식의 주된 장점은 구현과 디버깅의 간단함에 있다. 각 계층은 단지 자신의 하위층들의 서비스와 기능(연산)들만을 사용하도록 선택된다. 이러한 접근 방법은 시스템의
검증과 디버깅 작업을 단순화한다. 첫 번째 층은 정의에 의해 하드웨어(올바른 것으로 간주)만을 사용하여 이 층의 기능을 구현하기 때문에, 나머지 시스템에 아무런 신경을 쓰지 않고 
디버깅할 수 있다. 첫 번째 층의 디버깅이 끝나면, 두 번째 층을 디버깅하는 동안 그것이 정확하게 동작한다고 가정될 수 있으며, 이러한 과정이 반복된다. 만일 어느 층의 디버깅 중
오류가 발견되면 그 하위의 층은 이미 디버깅되었기 때문에 오류는 반드시 그 층에 있다. 따라서 시스템을 계층으로 나누면 시스템의 설계나 구현이 간단해진다.
- 각 층은 자신보다 하위 층에 의해 제공된 연산들만 사용해 구현한다. 한 층은 이러한 연산들이 어떻게 구현되는지 알 필요가 없고, 다만 이러한 연산들이 무엇을 하는지만 알면 된다.
그러므로 각 층은 특정 데이터 구조, 연산, 그리고 하드웨어의 존재를 상위 층에 대해 숨기게 된다. 
- 계층화된 시스템은 컴퓨터 네트워크 (예: TCP/IP) 및 웹 응용 프로그램에서 성공적으로 사용됐다. 그럼에도 불구하고 순수한 계층 접근 방식을 사용하는 운영체제는 비교적 적다.
한 가지 이유는 각 계층의 기능을 적절하게 정의해야 하는 문제와 관련있다. 또한 이러한 시스템의 전반적인 성능은 운영체제 서비스를 얻기 위해 사용자 프로그램이 여러 계층을
통과해야 하는 오버헤드로 인해 열악하다. 그러나 어느 정도의 계층화는 현대 운영체제에서 공통적이다. 일반적으로 이러한 시스템은 더 많은 기능을 가진 더 적은 개수의 층을 가지므로
층 기능의 정의 및 상호작용의 문제를 피하면서 모듈화된 코드의 장점을 최대한 활용할 수 있다.

## 2.8.3 마이크로커널 (Microkernels)
- 우리는 이미 초기 UNIX 시스템이 모놀리식 구조를 가진다는 것을 보았다. UNIX가 확장함에 따라, 커널이 커지고 관리하기 힘들어졌다. 1980년대 중반에, Carnegie Mellon 
대학교의 연구자들이 마이크로커널 접근 방식을 사용하여 커널을 모듈화한 Mach라 불리는 운영체제를 개발하였다. 이 방법은 모든 불필요한 구성요소를 커널로부터 제거하고, 그들을 별도의
주소 공간에 존재하는 사용자 수준 프로그램으로 구현하여 운영체제를 구성하는 방법이다. 결과는 더 작은 커널이다. 어느 서비스가 커널에 남아 있어야 하고, 어느 서비스가 사용자 공간에
구현되어야 할지에 대해서는 의견이 일치하지 않는다. 그러나 일반적으로 마이크로커널은 통신 기능 외에 최소한의 프로세스 및 메모리 관리를 제공한다.
- 마이크로커널의 주 기능은 클라이언트 프로그램과 사용자 공간에서 실행되는 다양한 서비스 간의 통신을 제공하는 것이다. 통신은 메시지 전달에 의해 제공된다. 예를 들면, 클라이언트
프로그램이 파일에 접근하기를 원하면, 파일 서버와 반드시 상호 작용해야 한다. 클라이언트 프로그램과 서비스는 결코 직접 상호 작용하지 않는다. 오히려, 그들은 마이크로커널과 메시지를
교환함으로써 간접적으로 상호작용한다.
- 마이크로커널 접근법의 한 가지 장점은 운영체제의 확장이 쉽다는 것이다. 모든 새로운 서비스는 사용자 공간에 추가되므로 커널을 변경할 필요 없다. 커널이 변경되어야만 할 때는,
마이크로커널이 작은 커널이기 때문에 변경할 대상이 비교적 적은 경향이 있다. 결과적으로 만들어지는 운영체제는 한 하드웨어로부터 다른 하드웨어로 이식이 쉽다. 마이크로커널은 서비스
대부분이 커널이 아니라 사용자 프로세스로 수행되기 때문에 또한 더욱 높은 보안성과 신뢰성을 제공한다. 만일 한 서비스가 잘못되더라도, 운영체제의 다른 부분은 아무런 영향을 받지
않는다. 
- 마이크로커널 운영체제의 가장 잘 알려진 실례는 macOS 및 iOS 운영체제의 커널 구성요소인 Darwin이다. 실제로 Darwin은 두 개의 커널로 구성되며 그중 하나는 Mach 
마이크로커널이다.
- 또 다른 예는 임베디드 시스템용 실시간 운영체제인 QNX이다. QNX Neutrino 마이크로커널은 메시지 전달과 프로세스 스케줄링을 위한 서비스를 제공한다. 또한 저수준의 네트워크
통신과 하드웨어 인터럽트를 처리한다. QNX의 다른 모든 서비스는 사용자 모드로 커널 밖에서 수행되는 표준 프로세스들에 의해 제공된다.
- 안타깝게 마이크로커널은 시스템 기능 오버헤드 증가로 성능이 저하될 수 있다. 두 개의 사용자 수준 서비스가 통신해야 하는 경우 별도의 주소 공간에 서비스가 존재하기 때문에 
메시지가 복사되어야 한다. 또한 운영체제는 메시지를 교환하기 위해 한 프로세스에서 다음 프로세스로 전환해야 할 수도 있다. 메시지 복사 및 프로세스 전환과 관련된 오버헤드는
마이크로커널 기반 운영체제의 성장에 가장 큰 장애였다. Windows NT의 역사를 고려해보자. 첫 번째 릴리스에는 계층화된 마이크로커널 구조였다. 이 버전의 성능은 Windows 95에
비해서도 성능이 떨어졌다. Windows NT 4.0은 계층들을 사용자 공간으로부터 커널 공간으로 옮기고 더 밀접하게 통합함으로써 성능 문제를 부분적으로 개선하였다. Windows XP가
설계될 때까지 Windows 구조는 마이크로커널보다는 모놀리식에 가까운 구조였다. 

## 2.8.4 모듈 (Modules)
- 운영체제를 설계하는 데 이용되는 최근 기술 중 가장 좋은 방법은 아마도 적재가능 커널 모듈(loadable kernel modules, LKM) 기법의 사용일 것이다. 이 접근법에서는
커널은 핵심적인 구성요소의 집합을 가지고 있고, 부팅시 또는 런타임 중에 부가적인 서비스들을 모듈을 통해 링크할 수 있다. 이러한 유형의 설계는 Linux, Mac OS X, Solaris 및
Windows 등의 현대 UNIX 를 구현하는 일반적인 추세이다.
- 설계의 주안점은 커널은 핵심 서비스를 제공하고 다른 서비스들은 커널이 실행되는 동안 동적으로 구현하는 것이다. 서비스를 동적으로 링크하는 것은 새로운 기능을 직접 커널에 추가하는
것보다 바람직하다. 후자의 경우 수정 사항이 생길 때마다 커널을 다시 컴파일해야 한다. 예를 들어, CPU 스케줄링과 메모리 관리 알고리즘은 커널에 직접 구현하고 다양한 파일 시스템을
지원하는 것은 적재가능 모듈을 통하여 구현할 수 있다.
- 전체적인 결과는 커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서 계층 구조를 닮았다. 그러나 모듈에서 임의의 다른 모듈을 호출할 수 있다는 점에서 계층 구조보다
유연하다. 중심 모듈은 단지 핵심 기능만을 가지고 있고 다른 모듈의 적재 방법과 모듈들과 어떻게 통신하는지 안다는 점에서는 마이크로 커널과 유사하다. 그러나, 통신하기 위해 메시지
전달을 호출할 필요가 없기 때문에 더 효율적이다.
- Linux는 주로 장치 드라이버와 파일 시스템을 지원하기 위해 적재가능 커널 모듈을 사용한다. LKM은 시스템이 시작(또는 부팅)되거나 USB 장치가 실행 중인 시스템에 접속되는 경우와
같이 런타임 중에 커널에 "삽입"될 수 있다. Linux 커널에 필요한 드라이버가 없으면 동적으로 적재할 수 있다. LKM은 런타임 중에도 커널에서 제거될 수 있다. Linux의 경우 
LKM은 동적 및 모듈식 커널을 허용하면서 모놀리식 시스템의 성능 이점을 유지한다.

## 2.8.5 하이브리드 시스템 (Hybrid Systems)
- 사실 엄격하게 정의된 하나의 구조를 채택한 운영체제는 거의 존재하지 않는다. 대신 다양한 구조를 결함하여 성능, 보안 및 편리성 문제를 해결하려는 혼용 구조로 구성된다. 예를 들어,
Linux는 운영체제 전부가 하나의 주소 공간에 존재해 효율적인 성능을 제공하기 때문에 모놀리식 구조다. 그러나 이 운영체제들은 모듈을 사용하기 때문에 새로운 기능을 동적으로 커널에
추가할 수 있다. 역시 성능상의 이유로 Windows도 대체적으로 모놀리식 구조라 할 수 있다. 그러나 사용자 모드 프로세스로서 실행되는 분리된 서브시스템을, 운영체제의 인격이라고
알려진, 지원하는 등 전형적인 마이크로커널의 형태를 유지하고 있다. Windows 시스템은 또한 동적으로 적재가능 커널 모듈도 지원한다. 

### 2.8.5.1 macOS와 iOS
```text
응용 프로그램 -> 사용자 경험
응용 프로그램 -> 응용 프로그램 프레임워크
응용 프로그램 -> 코어 프레임워크
응용 프로그램 -> 커널 환경 (Darwin)
```
- Apple의 macOS 운영체제는 주로 데스크톱 및 랩톱 컴퓨터 시스템에서 실행되도록 설계되었으며, iOS는 iPhone 스마트폰 iPad 태블릿 컴퓨터용으로 설계된 모바일 운영체제이다.
구조적으로 macOS와 iOS는 공통점이 많다. 이 두 시스템의 다양한 층의 주요 특징은 다음과 같다.
  - 사용자 경험 층 : 이 층은 사용자가 컴퓨팅 장치와 상호 작용할 수 있는 소프트웨어 인터페이스를 정의한다. macOS는 마우스 또는 트랙패드 용으로 설계된 Aqua 사용자 
    인터페이스를 정의한다. macOS는 마우스 또는 트랙패드 용으로 설계된 Aqua 사용자 인터페이스를 사용하는 반면, iOS는 터치 장치용으로 설계된 Springboard 사용자 
    인터페이스를 사용한다.
  - 응용 프로그램 프레임워크 층 : 이 층에는 Cocoa 및 Cocoa Touch 프레임워크가 포함되며 Object-C 및 Swift 프로그래밍 언어에 대한 API를 제공한다. Cocoa와 
    Cocoa Touch의 주요 차이점은 전자는 macOS 응용 프로그램 개발에 사용되고 후자는 iOS가 터치스크린과 같은 모바일 장치에 고유한 하드웨어 기능을 지원하는 데 사용된다는 것.
  - 코어 프레임워크 : 이 층은 Quicktime 및 OpenGL을 포함한 그래픽 및 미디어를 지원하는 프레임워크를 정의한다.
  - 커널 환경 : Darwin이라고도 불리는 이 환경에는 Mach 마이크로커널과 BSD UNIX 커널이 포함된다.
- 응용 프로그램은 사용자 경험 기능을 이용하거나 이 기능을 우회하여 응용 프로그램 프레임워크 또는 핵심 프레임워크와 직접 상호 작용하도록 설계될 수 있다. 또한 응용 프로그램은
프레임워크를 완전히 버리고 커널 환경과 직접 통신할 수 있다. (후자의 예는 사용자 인터페이스 없이 POSIX 시스템 콜을 수행하도록 작성된 C 프로그램이다.)
- macOS 와 iOS 의 중요한 차이점은 다음과 같다.
  - macOS는 데스크톱 및 랩톱 컴퓨터 시스템용이므로 Intel 아키텍처에서 실행되도록 컴파일된다. iOS는 모바일 장치용으로 설계되었으므로 ARM 기반 아키텍처용으로 컴파일된다.
    iOS는 모바일 장치용으로 설계되었으므로 ARM 기반 아키텍처용으로 컴파일된다. 마찬가지로 iOS 커널은 전원 관리 및 공격적인 메모리 관리와 같은 모바일 시스템의 특정 기능과
    요구를 해결하기 위해 약간 수정되었다. 또한 iOS에는 macOS보다 더 엄격한 보안 설정이 있다.
  - iOS 운영체제는 일반적으로 macOS 보다 개발자에게 훨씬 더 제한적이며, 더 폐쇄적일 수도 있다. 예를 들어, iOS는 iOS에서 POSIX 및 BSD API에 대한 액세스를 제한하는 
    반면, macOS 에서 개발자는 공개적으로 사용할 수 있다.
- 하이브리드 구조를 사용하는 Darwin은 주로 Mach 마이크로커널과 BSD UNIX 커널로 구성된 계층화된 시스템이다. 
- 운영체제 대부분은 UNIX 및 Linux 시스템에서 표준 C 라이브러리를 통하는 것처럼 커널에 대해 하나의 시스템 콜 인터페이스를 제공하는 반면 Darwin은 Mach 시스템 콜(트랩
이라고 함)과 BSD 시스템 콜 (POSIX 기능 제공) 두 개의 시스템 콜 인터페이스를 제공한다. 이러한 시스템 콜에 대한 인터페이스는 표준 C 라이브러리뿐만 아니라 네트워킹, 보안
및 프로그래밍 언어 지원을 제공하는 라이브러리를 포함하는 풍부한 라이브러리 집합이다.
- 시스템 콜 인터페이스 아래에서 Mach는 메모리 관리, CPU 스케줄링, 메시지 전달 및 원격 프로시저 호출(remote procedure call, RPC)과 같은 프로세스 간 통신(IPC)
기능을 포함한 기본 운영체제 서비스를 제공한다. Mach 에서 제공하는 대부분의 기능은 커널 추상화를 통해 사용 가능하다. 이 추상화에는 태스크(Mach 프로세스), 스레드, 메모리
객체 및 포트 (IPC에 사용)가 포함된다. 예를 들어, 응용 프로그램은 BSD POSIX fork() 시스템 콜을 사용하여 새 프로세스를 생성할 수 있다. Mach는 커널 내에서 프로세스를
나타내기 위해 태스크 커널 추상화를 사용한다.
- Mach 및 BSD 외에도 커널 환경은 장치 드라이버 및 동적 적재가능 모듈(macOS는 커널 확장 또는 kext라고 함) 개발을 위한 I/O 키트를 제공한다.
- 앞에서 사용자 공간에서 실행되는 서로 다른 서비스 간에 메시지 전달 오버헤드가 어떻게 마이크로커널의 성능을 손상하는지 보았따. 이러한 성능 문제를 해결하기 위해 Darwin은
Mach, BSD, I/O 키트 및 모든 커널 확장을 단일 주소 공간으로 결합한다. 따라서 다양한 하위 시스템이 사용자 공간에서 실행된다는 관점에서 본다면 Mach는 순수한 마이크로커널이
아니다. Mach 내에서 메시지 전달은 여전히 발생하지만 서비스가 동일한 주소 공간에 액세스 할 수 있으므로 복사할 필요 없다.
- Apple Darwin 운영체제를 오픈 소스로 배포하였다. 그 결과 X-11 윈도 시스템 및 추가 파일 시스템 지원과 같은 다양한 프로젝트가 Darwin에 부가적인 기능을 추가하였다.
그러나 Darwin과 달리 Cocoa 인터페이스와 macOS 응용 프로그램 개발에 사용할 수 있는 다른 독점적 Apple 프레임워크는 비공개 상태이다.

### 2.8.5.2 Android
- Android 운영체제는 Open Handset Alliance (Google이 주도)가 설계하였으며 Android 스마트폰과 태블릿을 위해 개발되었다. iOS가 Apple의 모바일 장치에서 실행하기
위해 설계되었고 소스가 공개되지 않는 데 반해, Android는 다양한 모바일 플랫폼에서 실행되며 오픈 소스이다. 오픈 소스라는 이유가 빠르게 인기가 높아졌던 이유 중 일부분을 
차지한다.
- Android는 그래픽, 오디오 및 하드웨어 기능을 지원하는 다양한 프레임워크를 제공하는 계층화된 소프트웨어 스택이라는 점에서 iOS와 유사하다. 그 결과 이러한 기능은 다양한
Android 지원 장치에서 실행되는 모바일 응용 프로그램을 개발하기 위한 플랫폼을 제공한다.
- Android 장치의 소프트웨어 설계자는 Java 언어로 응용 프로그램을 개발하지만 일반적으로 표준 Java API를 사용하지 않는다. Google은 Java 개발을 위해 별도의 Android
API를 설계하였다. Java 응용 프로그램은 Android RunTime ART 에서 실행할 수 있는 형식으로 컴파일된다. ART는 Android용으로 설계되어 메모리와 CPU 처리능력이 제한적인
모바일 장치에 최적화된 가상 머신이다. Java 프로그램은 우선 Java 바이트 코드 .class 파일로 컴파일된 후 실행 가능한 .dex 파일로 변환된다. 많은 Java 가상 머신이 응용
프로그램 효율성을 향상시키기 위해 JIT (Just-In-Time)멐파일을 수행하는 반면, ART는 AOT(ahead-of-time) 컴파일을 수행한다. 이제 .dex 파일은 장치에 설치될 때 해당
기계어 코드로 컴파일되어 ART에서 실행될 수 있게 된다. AOT 컴파일은 모바일 시스템에 중요한 기능인 전력 소비를 줄이면서 더 효율적인 응용 프로그램 실행을 가능하게 한다.
- Android 개발자는 개발자가 가상 머신을 우회할 수 있게 하는 Java 네이티브 인터페이스(또는 JNI)를 사용하는 Java 프로그램을 작성하여 특정 하드웨어 기능에 액세스할 수 있는
프로그램을 작성할 수 잇다. JNI를 사용하여 작성된 프로그램은 일반적으로 한 하드웨어 장치에서 다른 하드웨어 장치로 이식할 수 없다.
- Android 응용 프로그램에서 사용 가능한 네이티브 라이브러리 집합에는 웹 브라우저(webkit), 데이터베이스 지원(SQLite) 및 네트워크 소켓(예:SSL)을 개발하기 위한 
프레임워크가 포함된다.
- Android는 거의 무제한의 하드웨어 장치에서 실행할 수 있으므로 Google은 하드웨어 추상화 계층 또는 HAL을 통해 물리적 하드웨어를 추상화하기로 선택하였다. HAL은 카메라,
GPS 칩 및 기타 센서와 같은 모든 하드웨어를 추상화하여 특정 하드웨어와 상관없이 일관된 뷰를 응용 프로그램에게 제공한다. 물론 이 기능으로 개발자는 다른 하드웨어 플랫폼에서
이식 가능한 프로그램을 작성할 수 있다.
- Linux 시스템에서 사용하는 표준 C 라이브러리는 GNU C 라이브러리(glibc)이다. 대신 Google은 Android를 위한 Bionic 표준 C 라이브러리를 개발하였다. Bionic은
glibc보다 메모리 사용량이 적을 뿐만 아니라 모바일 장치를 특정짓는 느린 CPU를 위해 설계되었다. (또한 Bionic을 통해 Google이 glibc의 GPL 라이선스를 우회하도록
허용한다.)
- Android 소프트웨어 스택의 맨 아래에는 Linux 커널이 있다. Google은 전원 관리와 같은 모바일 시스템의 특수한 요구를 지원하기 위해 다양한 영역에서 Android에서
사용되는 Linux 커널을 수정하였다. 또한 메모리 관리 및 할당을 변경했으며, Binder 로 알려진 새로운 형태의 IPC를 추가하였다.

