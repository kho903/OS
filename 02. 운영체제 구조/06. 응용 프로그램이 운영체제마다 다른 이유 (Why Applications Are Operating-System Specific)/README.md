# 2.6 응용 프로그램이 운영체제마다 다른 이유 (Why Applications Are Operating-System Specific)
- 기본적으로 한 운영체제에서 컴파일된 응용 프로그램은 다른 운영체제에서 실행 불가. 만약 그랬다면, 세상은 더 나은 곳이 되었을 것이며 사용할 운영체제의 선택은 가용한 응용 
프로그램이 아닌 유용성과 기능에 달려 있었을 것이다.
- 각 응용체제는 고유한 시스템 콜 집합을 제공한다. 시스템 콜은 응용 프로그램이 사용할 수 있도록 운영체제가 제공하는 서비스 집합의 일부이다. 시스템 콜은 어느 정도 같더라도, 다른
장벽으로 인해 응용 프로그램을 다른 운영체제에서 실행하기 어렵다. 그러나 여러 운영체제를 사용했을 떄, 동일한 응용 프로그램을 다른 운영체제에서 사용했을 수도 있다. 어떻게 가능할까?
- 다음 3가지 방법 중 한 가지를 사용하여 응용 프로그램이 여러 운영체제에서 실행될 수 있게 만들 수 있다.
1. 응용 프로그램은 운영체제마다 인터프리터가 제공되는 인터프리터 언어 (예 : Python 또는 Ruby)로 작성될 수 있다. 인터프리터는 소스 프로그램의 각 라인을 읽고, 상응하는
기계어 명령어를 실행하고, 해당 운영체제의 시스템 콜을 호출한다. 기계어 코드로 구성된 응용 프로그램에 비해 성능이 떨어지고, 인터프리터는 각 운영체제의 일부만 제공하므로,
관련 응용 프로그램의 기능도 제한될 수 있다.
2. 응용 프로그램은 실행 중인 응용 프로그램을 포함하고 있는 가상 머신을 가진 언어로 작성될 수 있다. 가상 머신은 언어의 RTE 중 일부이다. 이 방법의 예로 Java를 들 수 있다.
Java는 로더, 바이트코드 검증기 및 Java 응용 프로그램을 Java 가상 머신으로 적재하는 기타 구성요소를 RTE로 가지고 있다. 이 RTE는 메인 프레임에서 스마트폰에 이르기까지
많은 운영체제에 이식 또는 개발되었으며, 이론적으로 모든 Java 앱은 RTE가 제공되는 어디서나 실행될 수 있다. 이러한 종류의 시스템은 위에서 설명한 인터프리터 시스템과 
유사한 단점을 가진다.
3. 응용 프로그램 개발자는 컴파일러가 기기 및 운영체제 고유의 이진 파일을 생성하는 표준 언어 또는 API를 사용할 수 있다. 응용 프로그램은 실행될 각 운영체제로 이식되어야 한다.
이 이식은 많은 시간이 소요될 수 있으며 많은 테스트와 디버깅을 거쳐 응용 프로그램의 새 버전마다 수행되어야 한다. 아마도 가장 잘 알려진 예는 다양한 UNIX 운영체제 변종 간의
소스 코드 호환성을 유지하기 위한 POSIX API와 표준 집합이다.

- 이론적으로 이 3가지 접근 방식은 다양한 운영체제에서 실행될 수 있는 응용 프로그램을 개발하기 위한 간단한 솔루션을 제공하는 것 같다. 그러나 일반적으로 응용 프로그램의 이동성이
부족한 데에는 여러 가지 원인이 있으며, 이로 인해 여전히 크로스 플랫폼 응용 프로그램을 개발하는 것이 어려운 작업이다. 응용 프로그램 수준에서 운영체제와 함께 GUI 인터페이스와
같은 기능을 제공하는 라이브러리가 포함되어 있으며, 하나의 API 집합 (예 : Apple iPhone의 iOS에서 사용 가능한 API)를 호출하도록 설계된 응용 프로그램은 해당 API를 
제공하지 않는(예 : Android) 운영체제에서는 작동하지 않는다. 다음을 포함해 시스템의 낮은 수준에는 다른 어려운 점이 존재한다.
  - 각 운영체제에는 헤더, 명령어 및 변수의 배치를 강제하는 응용 프로그램 이진 형식이 있다. 이러한 구성요소는 명시된 구조 형태로 실행 파일 내의 특정 위치에 있어야 운영체제가
    파일을 열고 응용 프로그램을 적재하여 올바르게 실행할 수 있다.
  - CPU는 다양한 명령어 집합을 가지며 해당 명령어가 포함된 응용 프로그램만 올바르게 실행할 수 있다.
  - 운영체제는 응용 프로그램이 파일 생성과 네트워크 연결 열기와 같은 다양한 호라동을 요청할 수 있는 시스템 콜을 제공한다. 이러한 시스템 콜은 사용되는 피연산자, 피연산자 순서,
    응용 프로그램이 시스템 콜을 호출하는 방법, 시스템 콜 번호, 의미, 결과 반환 등 여러 측면에서 운영체제마다 다르다.
- 이러한 구조적 차이점을 완전히 해결하지는 못했지만 해결하는 데 도움이 되는 몇 가지 방법이 있다. 예를 들어 Linux와 거의 모든 UNIX 시스템에서 이진 실행 파일은 ELF 형식을
채택하였다. ELF는 Linux 및 UNIX 시스템에서 공통 표준을 제공하지만, ELF 형식은 특정 컴퓨터 아키텍처와 연관되어 있지 않으므로 실행 파일이 다른 하드웨어 플랫폼에서 실행될 
것이라는 보장은 없다.
- 위에서 언급했듯이 API는 응용 프로그램 수준에서 특정 기능을 지정한다. 아키텍처 수준에서 이진 코드의 여러 구성요소가 주어진 아키텍처에서 특정 운영체제와 상호 작용할 수 있는
방법을 정의하는 데 ABI (applcation binary interface)가 사용된다. ABI는 주소 길이, 시스템 콜에 매개변수를 전달하는 방법, 런타임 스택 구성, 시스템 라이브러리의 이진
형식 및 데이터 유형의 크기 등의 하위 수준의 세부 정보를 명시한다. 일반적으로 ABI는 특정 아키텍처에 대해 명시된다. (예 : ARMv8 프로세서에 대한 ABI가 있음). 따라서, ABI는
아키텍처 수준의 API이다. 이진 실행 파일이 특정 ABI에 따라 컴파일되고 링크된 경우 해당 ABI 를 지원하는 다른 시스템에서 실행될 수 있어야 한다. 그러나 특정 아키텍처에서
실행되는 특정 운영체제에 대해 ABI가 정의되어 있기 때문에 ABI는 플랫폼 간 호환성을 거의 제공하지 않는다.
- 요약하면, 이러한 모든 차이점은 특정 CPU 유형(예 : Intel x86 또는 ARMv8)의 특정 운영체제에서 인터프리터, RTE 또는 이진 실행 파일을 작성하고 컴파일하지 않으면, 응용
프로그램이 실행되지 않는다는 것을 의미한다. Firefox 브라우저와 같은 프로그램이 Windows, macOS, 다양한 Linux 릴리스, iOS 및 Android, 때로는 다양한 CPU 아키텍처에서
실행되는 데 필요한 작업량을 상상해보자.
