# 2.7 운영체제 설계 및 구현 (Operating-System Design and Implement)
- 이 절에서는 운영체제 설계 구현시, 당면하는 문제점을 논의. 물론 이들 설계 문제점에 대한 완전한 해결책은 없지만, 성공적인 접근 방법들이 있다.

## 2.7.1 설계 목표 (Design Goals)
- 시스템을 설계하는 데에 첫쨰 문제점은 시스템의 목표와 명세를 정의하는 일이다. 시스템 설계는 최상위 수준에서는 하드웨어와 시스템 유형 (일괄처리, 시분할, 단일 사용자, 다중
사용자, 분산, 실시간 혹은 범용)의 선택에 의해 영향을 받을 것이다.
- 이 최상위 설계 수준을 넘어서면 요구 조건들을 일일이 명시하는 것이 훨씬 어려워진다. 그러나 이러한 요구 조건은 근본적으로 사용자 목적과 시스템 목적의 두가지 기본 그룹으로
나눌 수 있다.
- 사용자들이 시스템에 기대하는 특징들이 존재한다. 시스템은 사용하기 쉽고, 편리하며, 배우기 쉽고, 믿을 수 있고, 안전하고, 신속해야 한다. 물론 이러한 특징을 구현하는 방법에
대해 일반적으로 합의된 사항이 없기 떄문에, 시스템을 설계할 때 이러한 명세가 쓸모가 있지는 않다.
- 이와 유사한 요구 조건들이 시스템을 설계, 생성, 유지, 조작해야 하는 사람들에 의해 정의될 수 있다. 즉, 운영체제는 설계, 구현, 유지 보수가 쉬워야 하며, 또한 적응성,
신뢰성, 무오류, 효율성을 가져야 한다. 앞서와 마찬가지로 이러한 요구 조건들은 모호하며 다양하게 해석될 수 있따.
- 요약하면 운영체제에 대한 요구를 정의하는 문제를 해결하는 유일한 해법은 없다. 많은 시스템에서 다른 요구 조건들이 다른 환경을 위해 다양한 해결 방법을 낳을 수 있음을 보여준다.
예를 들면, 임베디드 시스템용 실시간 운영체제인 Wind River VxWorks의 요구 사항은 엔터프라이즈(기업용) 응용 프로그램을 위해 설계된 대규모의 다중 접근 운영체제인 Windows
Server를 위한 구 조건과는 크게 다를 것이 틀림없다.
- 운영체제의 명세와 설계는 매우 창조적인 일이다. 어떤 교재도 이런 문제점을 해결하는 방법을 알려 줄 수는 없지만, 소프트웨어 공학 분야에 의해 개발된, 특정 운영체제에 적용
가능한 일반적인 원칙들이 존재한다.

## 2.7.2 기법과 정책 (Mechanisms and Policies)
- 한 가지 중요한 원칙은 기법(mechanism)으로 부터 정책을 분리하는 것이다. 기법은 어떤 일을 "어떻게" 할 것인가를 결정하는 것이고, 정책은 "무엇을" 할 것인가를 결정하는
것이다. 예를 들면, 타이머 구성은 CPU 보호를 보장하기 위한 기법이지만, 특정 사용자를 위해 타이머를 얼마나 오랫동안 설정할지를 결정하는 것은 정책적 결함이다.
- 정책과 기법의 분리는 융통성을 위해 아주 중요하다. 정책은 장소가 바뀌거나 시간이 흐름에 따라 변경될 수 있다. 최악의 경우, 정책의 각 변경이 저변에 깔린 기법의 변경을 요구하게
된다. 여러 정책에서 사용되기에 충분한 융통성 있는 일반적인 기법이 더 바람직하다. 그렇게 되면 정책의 변경은 시스템의 일부 매개변수만을 재정의 하도록 요구한다. 예를 들면, 한
유형의 프로그램이 다른 유형의 프로그램보다 높은 우선순위를 가지도록 하는 기법을 생각해보자. 만일 기법이 정책으로부터 적절하게 분리되면, 입출력 중심 프로그램이 CPU 중심 프로그램
보다 높은 우선순위를 가지도록 하는 정책을 지원하거나 그 반대 정책을 지원할 수 있다.
- 마이크로 커널 기반 운영체제는, 프리미티브 빌딩 블록의 기본 집합을 구현함으로써 기법과 정책의 분리를 극단적으로 추구한다. 이 블록들은 정책으로부터 거의 자유로우며, 더 고급의
기법과 정책들이 사용자 생성 커널 모듈이나 사용자 프로그램 자체를 통해 추가될 수 있도록 한다. 반면에 30년 넘게 널리 사용되는 Windows를 생각해보자. Microsoft는 Windows
운영체제를 실행하는 모든 장치에서 전체적인 모양과 느낌을 통일하기 위해 기법과 정책이 밀접해지도록 인코딩했다. 인터페이스 자체가 커널 및 시스템 라이브러리에 내장되어 있으므로,
모든 응용 프로그램의 인터페이스는 유사하다. Apple 은 MacOS 및 iOS 운영체제에 유사한 전략을 채택했다.
- 상용 운영체제와 오픈 소스 운영체제 간에도 비슷하게 비교할 수 있다. 예를 들어 위에서 언급한 Windows와 광범위한 컴퓨팅 장치에서 실행되며, 25년 이상 사용되어 온 오픈 소스
Linux와는 대조적이다. "표준" Linux 커널에는 특정 CPU 스케줄링 알고리즘이 있고, 이 알고리즘은 특정 정책을 지원하는 기법이다. 그러나 누구나 다른 정책을 지원하기 위해
스케줄러를 자유롭게 수정하거나 교체할 수 있다.
- 정책 결정은 모든 자원 할당 문제에 있어서 중요하다. 자원의 할당 여부를 결정할 필요가 있을 때마다 정책 결정을 해야 한다. 질문이 무엇(what)이 아니라 어떻게(how)일 때마다,
반드시 결정되어야 하는 것은 기법이다.

## 2.7.3 구현 (Implementation)
- 운영체제의 설계가 완료되면 구현되어야 한다. 운영체제는 많은 사람에 의해 오랫동안 개발된 많은 프로그램의 집합체이기 때문에 구현 방법에 대해 일반적인 언급을 하는 것은 어렵다.
- 초기 운영체제는 어셈블리 언어로 작성되었따. 이제 대부분은 C/C++ 과 같은 고급 언어로 작성되며, 극히 일부의 시스템이 어셈블리 언어로 작성된다. 실제로, 둘 이상의 고급 언어가
종종 사용된다. 커널의 최하위 레벨은 어셈블리 언어 및 C로 작성될 수 있다. 상위 레벨 루틴은 C/C++로 작성될 수 있으며, 시스템 라이브러리는 C++ 또는 상위 레벨 언어로 작성될 수
있다. Android는 좋은 예를 제공한다. 커널은 대부분약간의 어셈블리 언어를 함께 사용하고 C로 작성되었따. 대부분의 Android 시스템 라이브러리는 C/C++로 작성되며 시스템 개발자
인터페이스를 제ㅐ공하는 응용 프로그램 프레임워크는 대부분 Java로 작성된다.
- 운영체제를 구현하기 위해 고급 언어 또는 최소한 시스템 구현 언어를 사용함으로써 생기는 장점은 그 언어가 응용 프로그램에 사용될 때 생기는 이점과 동일하다. 즉, 코드를 빨리 
작성할 수 있으며, 더욱 간결하고, 이해하기 쉽고, 디버그하기도 쉽다. 추가로, 컴파일러 기술의 향상은, 단순한 재 컴파일에 의해 전체 운영체제를 위해 생성된 코드를 개선할 것이다.
마지막으로, 운영체제가 고급 언어로 작성된 경우, 다른 하드웨어로 이식하는 것이 훨씬 쉽다. 이는 소형 임베디드 장치, Intel x86 시스템 및 전화 및 태블릿에서 실행되는 ARM 칩과
같이 여러 가지 다른 하드웨어 시스템에서 실행되어야 하는 운영체제에서 특히 중요하다.
- 운영체제를 고급 언어로 구현하는 것에 대해 주로 주장되는 단점은 속도가 느리고 저장 장치가 많이 소요되는 것이다. 그러나 이것은 현재의 시스템에서는 주된 문제가 아니다. 전문적인
어셈블리 언어 프로그래머는 효율적인 작은 루틴을 생산할 수 있지만, 현대의 컴파일러는 대규모 프로그램을 위해 복잡한 분석을 수행하고 정교한 최적화를 적용하여 우수한 코드를 
생산할 수 있다. 최신 프로세서는 심층 파이프라이닝과 다수의 기능 장치를 가지며 이들 기능 장치는 인간이 할 수 있는 것보다 훨씬 쉽게 복잡한 의존성의 상세 사항들을 처리할 수 있다.
- 다른 시스템에서도 알려진 사실이지만, 운영체제의 주요 성능 향상은 우수한 어셈블리어 코드보다는 더 나은 자료 구조와 알고리즘의 결과일 가능성이 크다. 게다가 운영체제가 크긴
하지만, 단지 소량의 코드만이 고성능이 중요하다. 아마도 인터럽트 핸들러, 입출력 관리자, 메모리 관리자와 CPU 스케줄러가 가장 중요한 루틴일 것이다. 시스템이 개발되고 올바르게
작동된 후 병목 지점을 식별하고 보다 효율적으로 작동하도록 재구성(리팩토링)할 수 있다.

