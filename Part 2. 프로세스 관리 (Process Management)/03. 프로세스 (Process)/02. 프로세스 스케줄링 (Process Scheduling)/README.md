# 프로세스 스케줄링 (Process Scheduling)
- 다중 프로그래밍의 목적은 CPU 이용을 최대화하기 위해 항상 어떤 프로세스가 실행되도록 하는 데 있다.
- 시분할의 목적은 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스들 사이에서 CPU 코어를 빈번하게 교체하는 것이다.
- 이 목적을 달성하기 위해 프로세스 스케줄러는 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택한다. 각 CPU 코어는 한 번에 하나의 프로세스를 실행할 수 있다.
- 단일 CPU 코어가 있는 시스템의 경우 한 번에 2개 이상의 프로세스가 실행될 수 없지만, 다중 코어 시스템은 한 번에 여러 프로세스를 실행할 수 있다.
- 코어보다 많은 프로세스가 있는 경우 초과 프로세스는 코어가 사용 가능해지고 다시 스케줄 될 때까지 기다려야 한다.
- 현재 메모리에 있는 프로세스 수를 다중 프로그래밍 정도라고 한다.


- 다중 프로그래밍 및 시간 공유의 목표를 균형 있게 유지하려면 프로세스의 일반적인 동작을 고려해야 한다. 
- 일반적으로 대부분의 프로세스는 I/O 바운드 또는 CPU 바운드로 설명할 수 있다.
- I/O 바운드 프로세스는 계산에 소비하는 것보다 I/O에 더 많은 시간을 소비하는 프로세스이다. 반대로 CPU 바운드 프로세스는 계산에 더 많은 시간을 사용하여 I/O 요청을 자주 생성하지 않는다.

## 3.2.1 스케줄링 큐 (Scheduling Queue)
- 프로세스가 시스템에 들어가면 준비 큐에 들어가서 준비 상태가 되어 CPU 코어에서 실행되기를 기다린다. 이 큐는 일반적으로 연결 리스트로 저장된다.
- 준비 큐 헤더에는 리스트의 첫 번째 PCB에 대한 포인터가 저장되고 각 PCB에는 준비 큐의 다음 PCB를 가리키는 포인터 필드가 포함된다.


- 시스템에는 다른 큐도 존재한다. 프로세스에 CPU 코어가 할당되면 프로세스는 잠시 동안 실행되어 결국 종료되거나 인터럽트 되거나 I/O 요청의 완료와 같은 특정 이벤트가 발생할 때까지 기다린다.
- 프로세스가 디스크와 같은 장치에 I/O 요청을 한다고 가정하자. 장치는 프로세서보다 상당히 느리게 실행되므로 프로세스는 I/O가 사용 가능할 때까지 기다려야 한다.
- I/O 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스는 대기 큐 (wait queue)에 삽입된다.


- 프로세스 스케줄링의 일반적인 표현은 큐잉 다이어그램이다. 준비 큐와 대기 큐의 집합의 두 가지 유형의 큐가 제시되어 있다.
- 원은 큐에 서비스를 제공하는 자원을 나타내고 화살표는 시스템의 프로세스의 흐름을 나타낸다.


- 새 프로세스는 처음에 준비 큐에 놓인다. 프로세스는 실행을 위해 선택되거나 또는 디스패치 될 때까지 기다린다.
- 프로세스에 CPU 코어가 할당되고 실행 상태가 되면, 여러 이벤트 중 하나가 발생할 수 있다.
    - 프로세스가 I/O 요청을 공표한 다음 I/O 대기 큐에 놓일 수 있다.
    - 프로세스는 새 자식 프로세스를 만든 다음 자식의 종료를 기다리는 동안 대기 큐에 놓일 수 있다.
    - 인터럽트 또는 타임 슬라이스 만료로 프로세스가 코어에서 강제로 제거되어 준비 큐로 돌아갈 수 있다.
- 처음 2 경우는 프로세스가 결국 대기 상태에서 준비 상태로 전환된 다음 준비 큐에 다시 들어간다.
- 프로세스는 종료될 때까지 이 주기를 계속한다. 종료 시점에 모든 큐에서 제거되고 PCB 및 자원이 반환된다.

## 3.2.2 CPU 스케줄링 (CPU Scheduling)
- 프로세스는 수명주기 동안 준비 큐와 다양한 대기 큐를 이주한다. CPU 스케줄러의 역할은 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU 코어를 할당하는 것이다.
- CPU 스케줄러는 CPU를 할당하기 위한 새 프로세스를 자주 선택해야 한다. I/O 바운드 프로세스는 I/O 요청을 대기하기 전에 몇 밀리초 동안만 실행할 수 있다.
- CPU 바운드 프로세스에는 오랜 시간 동안 CPU 코어가 필요하지만 스케줄러는 프로세스에게 코어를 장기간 부여할 가능성이 없다. 대신 프로세스에서 CPU를 갖에로 제거하고 실행될 다른 프로세스를 
스케줄하도록 설계될 가능성이 높다.
- 따라서 CPU 스케줄러는 일반적으로 훨씬 더 자주 실행되지만 적어도 100밀리초마다 한 번씩 실행된다.


- 일부 운영체제는 스와핑이라는 중간 형태의 스케줄링이 있는데, 핵심 아이디어는 때로는 메모리(및 CPU에 대한 능동적 경쟁)에서 프로세스를 제거하여 다중 프로그래밍 정도를 감소시키는 것이 유리할
수 있다는 것이다.
- 나중에 프로세스를 메모리에 다시 적재할 수 있으며 중단된 위치에서 실행을 계속할 수 있다.
- 프로세스를 메모리에서 "스왑아웃"하여 현재 상태를 저장하고, 이후 디스크에서 메모리로 "스왑인"히여 상태를 복원할 수 있기 때문에 이 기법을 스와핑이라고 한다.
- 스와핑은 일반적으로 메모리가 초과 사용되어 가용공간을 확보해야 할 때만 필요하다.

## 3.2.3 문맥 교환 (Context Switch)
- 인터럽트는 운영체제가 CPU 코어를 현재 작업에서 뺏어 내어 커널 루틴을 실행할 수 있게 한다. 이러한 연산은 범용 시스템에서 자주 발생한다.
- 인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 문맥(Context)을 복구할 수 있도록 현재 실행 중인 프로세스의 현재 문맥을 저장할 필요가 있다. 이는 결국 프로세스를 중단했다가
재개하는 작업이다.
- 문맥은 프로세스의 PCB에 표현된다. 문맥은 CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보 등을 포함한다.
- 일반적으로 커널 또는 사용자 모드에서 CPU의 현재 상태를 저장하는 작업을 수행(state save)하고, 나중에 연산을 재개하기 위해 상태 복구 작업을 수행(state restore)한다.


- CPU 코어를 다른 프로세스로 교환하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요하다. 이 작업은 문맥 교환 (context switching)이라 한다.
- 문맥 교환이 일어나면, 커널은 과거 프로세스의 문맥을 PCB에 저장하고, 실행이 스케줄(예약)된 새로운 프로세스의 저장된 문맥을 복구한다.
- 문맥 교환이 진행될 동안 시스템이 아무런 유용한 일을 못 하기 때문에 문맥 교환 시간은 순수한 오버헤드이다.
- 교환 속도는 메모리의 속도, 반드시 복사되어야 하는 레지스터의 특수, 특수 명령어(모든 레지스터를 하나의 명령어로 보관하고 적재하는 것 같은)의 존재에 좌우되므로, 기계마다 다르다. 일반적인
속도는 마이크로초까지 분포되어 있다.


- 문맥 교환 시간은 하드웨어의 지원에 크게 좌우된다. 예를 들어, 일부 프로세서(처리기)들은 여러 개의 레지스터 집합을 제공한다. 여기서 문맥 교환은 현재 레지스터 집합에 대한 포인터를 
변경하기만 하면 된다. 물론 레지스터 집합보다 활성 프로세스가 더 많은 경우 시스템은 이전과 같이 레지스터 자료를 메모리에 복사하거나 메모리에 복사하는 데에 의존한다.
- 또한 운영체제가 복잡할수록, 문맥 교환시 해야 할 작업의 양이 더 많아진다. 복잡한 고급 메모리 관리 기법을 사용하면 문맥 교환 시 더 많은 자료들을 교환해야 한다.
- 예를 들어, 문맥 교환시 현재 프로세스의 주소 공간은 다음 태스크의 공간이 사용 준비되는 동안 반드시 보존되어야 한다. 주소 공간이 어떤 식으로 보존되고, 보존하기 위해 수행해야 할 작업의 
양은 운영체제의 메모리 관리 기법에 따라 달라진다.

