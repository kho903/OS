# 3.6 메시지 전달 시스템에서의 프로세스 간 통신 (IPC in Message-Passing Systems)
- 3.5절에서 서로 협력하는 프로세스가 공유 메모리 환경에서 어떻게 상호 통신을 행하는 지 알아보았다. 그 기법은 프로세스들이 메모리 영역을 공유할 것을 필요로 하며, 공유 메모리에 접근하고
조작하는 코드가 응용 프로그래머에 의해 명시적으로 작성되어야 했다. 
- 동일한 효과를 얻는 또 다른 방법으로 운영체제가 메시지 전달 설비를 통해 서로 협력하는 프로세스 간의 통신 수단을 제공해 주는 방법이 있다.


- 메시지 전달 방식은 동일한 주소 공간을 공유하지 않고도 프로세스들이 통신을 하고, 그들의 동작을 동기화할 수 있도록 허용하는 기법을 제공한다. 메시지 전달 방식은 통신하는 프로세스들이
네트워크에 의해 연결된 다른 컴퓨터들에 존재할 수 있는 분산 환경에서 특히 유용하다.
- 한 예로 월드 와이드 웹에 사용되는 chat 프로그램은 서로 메시지를 교환하여 통신하도록 설계될 수 있다.


- 메시지 전달 시스템은 최소한 두 가지 연산을 제공한다.
  - send(message) / receive(message)
- 프로세스가 보낸 메시지는 고정 길이일 수도 있고 가변 길이일 수도 있다. 고정 길이 메시지만 보낼 수 있다면, 시스템 수준의 구현은 간단하다. 그러나 이러한 제한은 프로그래밍 작업을 더
힘들게 한다.
- 반면에, 가변 길이 메시지는 보다 복잡한 시스템 수준의 구현이 있어야 하지만, 프로그래밍 작업은 더 간단해진다. 이러한 일은 운영체제 설계 전반에 걸쳐 흔히 볼 수 있는 교환이다.


- 만약 프로세스 P와 Q가 통신을 원하면, 반드시 서로 메시지를 보내고 받아야 한다. 이들 사이에 통신 연결(communication link)이 설정되어야 한다. 이 연결은 다양한 방법으로 구현할 수
있다. 우리는 물리적 구현이 아닌 논리적인 구현에 관심이 있다. 하나의 링크와 send() / receive() 연산을 논리적으로 구현하는 다수의 방법은 다음과 같다.
1. 직접 또는 간접 통신
2. 동기식 또는 비동기식 통신
3. 자동 또는 명시적 버퍼링

## 3.6.1 명명 (Naming)
- 통신을 원하는 프로세스들은 서로를 가리킬 방법이 있어야 한다. 이들은 간접 통신 또는 직접 통신을 사용할 수 있다.
- 직접 통신하에서, 통신을 원하는 각 프로세스는 통신의 수신자 또는 송신자의 이름을 명시해야 한다. 이 기법에서 send(), receive() 프리미티브는 다음과 같이 정의한다.
  - send(P, message) : 프로세스 P에 메시지를 전송한다.
  - receive(Q, message) : 프로세스 Q로부터 메시지를 수신한다.
- 이 기법에서 통신 연결은 다음의 특성을 가진다.
  - 통신을 원하는 각 프로세스의 쌍들 사이에 연결이 자동으로 구축된다. 프로세스들은 통신하기 위해 상대방의 신원(identity)만 알면 된다.
  - 연결은 정확히 두 프로세스 사이에만 연관된다.
  - 통신하는 프로세스들의 각 쌍 사이에는 정확하게 하나의 연결이 존재해야 한다.
- 이 기법은 주소 방식에서 대칭성을 보인다. 즉, 송신자와 수신자 프로세스가 모두 통신하려면 상대방의 이름을 제시해야 한다.
- 이 기법의 변형으로서 주소 지정시에 비대칭을 사용할 수도 있다.
- 송신자만 수신자 이름을 지명하며, 수신자는 송신자의 이름을 제시할 필요가 없다. 이 기법에서 send()와 receive() 프리미티브는 다음과 같이 정의된다.
  - send(P, message) : 메시지를 프로세스 P에 전송한다.
  - receive(id, message) : 임의의 프로세스로부터 메시지를 수신한다. 변수 id는 통신을 발생시킨 프로세스의 이름으로 설정된다.
- 이들 기법(대칭적 그리고 비대칭적) 모두 프로세스를 지정하는 방식 때문에 모듈성을 제한한다는 것이 단점이다. 프로세스의 이름을 바꾸면 모든 다른 프로세스 지정 부분을 검사할 필요가
있을 수 있다. 이전 이름들에 대한 모든 참조를 반드시 찾아서 새로운 이름으로 변경해야 할 것이다.
- 일반적으로 이러한 하드 코딩(hard-coding) 기법은, 이 상황에서는 신원을 명시적으로 표시해야 한다. 하드코딩은 다음에 나올 간접적인 방식에 비해 바람직하지 않다.
- 간접 통신에서 메시지들은 메일박스(mailbox) 또는 포트(port)로 송신되고, 그것으로부터 수신된다.
- 메일박스는 추상적으로 프로세스들에 의해 메시지들이 넣어지고, 메시지들이 제거될 수 있는 객체라고도 볼 수 있다. 각 메일박스는 고유의 id를 가진다.
- 예를 들어 POSIX 메시지 큐는 메일박스를 식별하기 위해 정수 값을 사용한다. 이 기법에서 프로세스는 다수의 상이한 메일박스를 통해 다른 프로세스들과 통신할 수 있다. 두 프로세스들 공유
메일박스를 가질 때만 이들 프로세스가 통신할 수 있다. send()와 receive() 프리미티브들은 다음과 같이 정의할 수 있다.
  - send(A, message) : 메시지를 메일박스 A로 송신한다.
  - receive(A, message) : 메시지를 메일박스 A로부터 수신한다.
- 이 방법에서 통신 연결은 다음의 성질을 가진다.
  - 한 쌍의 프로세스들 사이의 연결은 이들 프로세스가 공유 메일박스를 가질 때만 구축된다.
  - 연결은 두 개 이상의 프로세스들과 연관될 수 있다.
  - 통신하고 있는 각 프로세스 사이에는 다수의 서로 다른 연결이 존재할 수 있고, 각 연결은 하나의 메일박스에 대응된다.
- 프로세스 P1, P2, P3 가 모두 메일박스 A를 공유한다고 가정하자. 프로세스 P1은 메시지를 A에 송신하고, P2와 P3는 각각 A로부터 receive()를 실행한다. 어느 프로세스가 P1이 보낸
메시지를 수신하는가? 이 문제의 답은 우리가 선택할 기법에 좌우된다.
  - 하나의 링크는 최대 두 개의 프로세스와 연관되도록 허용한다.
  - 한순간에 최대로 하나의 프로세스가 receive() 연산을 실행하도록 허용한다.
  - 어느 프로세스가 메시지를 수신할 것인지 시스템이 임의로 선택하도록 한다(즉, 두 프로세스 모두는 아니고, P2나 P3 중 하나가 메시지를 수신한다). 시스템이 언 프로세스가 수신할 것인지
    선택할 것인지를 선택하는 알고리즘을 정의할 수 있다(예 : 라운드로빈 방식에서는 프로세스가 돌아가면서 메시지를 수신한다). 시스템은 송신자에게 수신자를 알려줄 수 있다.
- 메일박스는 한 프로세스 또는 운영체제에 의해 소유될 수 있다. 메일박스가 한 프로세스에 의해 소유된다면(즉, 메일박스가 프로세스의 주소 공간의 일부이다), 우리는 소유자 (이 메일박스로부터
메시지를 수신만 가능한 프로세스)와 메일박스의 사용자를(메일박스에 메시지를 송신만 할 수 있는 프로세스) 구분할 수 있다. 각 메일박스가 고유한 소유자를 가지고 있기 떄문에, 이 메일박스로
보내진 메시지를 어느 프로세스가 수신할 지에 대한 혼란이 있을 수 없다. 메일박스를 소유하고 있는 프로세스가 종료할 때, 메일박스는 사라진다. 그 후에 이 메일박스로 메시지를 송신하는 모든
프로세스는 더는 메일 박스가 존재하지 않는다는 사실을 반드시 통보받아야 한다.


- 반면에, 운영체제가 소유한 메일박스는 자체적으로 존재한다. 이것은 독립적인 것으로 어떤 특정한 프로세스에 연결되지 않는다. 운영체제는 한 프로세스에 다음을 할 수 있도록 허용하는
기법을 반드시 제공해야 한다.
  - 새로운 메일박스를 생성한다.
  - 메일박스를 통해 메시지를 송신하고 수신한다.
  - 메일박스를 삭제한다.
- 새로운 메일박스를 생성하는 프로세스는 디폴트로 메일박스의 소유자가 된다. 초기에는, 소유자만이 이 메일박스를 통해 메시지를 수신할 수 있는 유일한 프로세스이다. 그러나 소유권과 수신 특권은
적절한 시스템 콜을 통해 다른 프로세스에 전달될 수 있다. 물론 이런 규칙으로 인해 메일박스마다 복수의 수신자를 낳을 수 있다.

## 3.6.2 동기화
- 프로세스 간의 통신은 send와 receive 프리미티브에 대한 호출에 의해 발생한다. 각 프리미티브를 구현하기 위한 서로 다른 설계 옵션이 있다. 메시지 전달은 봉쇄형(blocking)이거나
비봉쇄형(nonblocking) 방식으로 전달된다. 이 두 방식은 각각 동기식, 비동기식이라고도 알려져 있다.
  - 봉쇄형 보내기 : 송신하는 프로세스는 메시지가 수신 프로세스 또는 메일박스에 의해 수신될 때까지 봉쇄된다.
  - 비봉쇄형 보내기 : 송신하는 프로세스가 메시지를 보내고 작업을 재시작한다.
  - 봉쇄형 받기 : 메시지가 이용 가능할 때까지 수신 프로세스가 봉쇄된다.
  - 비봉쇄형 받기 : 송신하는 프로세스가 유효한 메시지 또는 널(null)을 받는다.
- send()와 receive()의 다른 조합도 가능하다. send() 와 receive()가 모두 봉쇄형일 때, 우리는 송신자와 수신자 간에 랑데부(rendezvous)를 하게 된다. 
- 봉쇄형 send()와 receive()를 사용한다면 생산자와 소비자 문제에 대한 해결책은 사소한 문제가 된다. 생산자는 단순히 봉쇄형 send()를 호출하고 메시지가 수신자 또는 메일박스에 전달될
때까지 기다린다. 유사하게 소비자가 receive()를 호출하면 메시지가 전달될 때까지 봉쇄된다.
- 메시지 전달을 사용하는 생산자 프로세스
```text
message next_produced;

while (true) {
    /* produced an item in next_produced */
    
    send(next_produced);
}
```
- 메시지 전달을 사용하는 소비자 프로세스
```text
message next_consumed;

while (true) {
    receive(next_consumed);
    
    /* consume the item in next_consumed */
}
```

## 3.6.3 버퍼링 (Buffering)
- 통신이 직접적이든 간접적이든 간에, 통신하는 프로세스들에 의해 교환되는 메시지는 임시 큐에 들어가 있다. 기본적으로 이러한 큐를 구현하는 방식은 세 가지가 있다.
  - 무용량(zero capacity) : 큐의 최대 길이가 0이다. 즉, 링크는 자체 안에 대기하는 메시지들을 가질 수 없다. 이 경우에, 송신자는 수신자가 메시지를 수신할 때까지 기다려야 한다.
  - 유한 용량(bounded capacity) : 큐는 유한한 길이 n을 가진다. 즉, 최대 n개의 메시지가 그 안에 들어 있을 수 있다. 새로운 메시지가 전송될 때 큐가 만원이 아니라면, 메시지는 큐에
    놓이며 (메시지가 복사되거나 메시지에 대한 포인터가 유지됨), 송신자는 대기하지 않고 실행을 계속한다. 그렇지만 링크는 유한한 용량을 가진다. 링크가 만원이면, 송신자는 큐 안에 공간이
    이용 가능할 때까지 반드시 봉쇄되어야 한다.
  - 무한 용량(unbounded capacity) : 큐는 잠재적으로 무한한 길이를 가진다. 따라서 메시지들이 얼마든지 큐 안에서 대기할 수 있다. 송신자는 절대 봉쇄되지 않는다.
- 무용량의 경우는 떄때로 버퍼링이 없는 메시지 시스템이라고도 한다. 다른 경우는 자동 버퍼링이라 부른다.
