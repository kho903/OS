# 3.5 공유 메모리 시스템에서의 프로세스 간 통신 (IPC in Shared-Memory Systems)
- 공유 메모리를 사용하는 프로세스 간 통신에서는 통신하는 프로세스들이 공유 메모리 영역을 구축해야 한다. 일반적으로 공유 메모리 영역은 공유 메모리 세그먼트를 생성하는 프로세스의 
주소 공간에 위치한다.
- 이 공유 메모리 세그먼트를 이용하여 통신하고자 하는 다른 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가하여야 한다. 일반적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근하는
것을 금지한다.
- 공유 메모리는 둘 이상의 프로세스가 이 제약 조건을 제거하는 것에 동의하는 것을 필요로 한다. 그런 후에 프로세스들은 공유 영역에 읽고 씀으로써 정보를 교환할 수 있다.
- 데이터의 형식과 위치는 이들 프로세스에 의해 결정되며 운영체제의 소관이 아니다. 또한 프로세스들은 동시에 동일한 위치에 쓰지 않도록 책임져야 한다.


- 협력하는 프로세스의 개념을 설명하기 위해서, 협력하는 프로세스의 일반적인 패러다임인 생상자-소비자 문제를 생각해보자.
- 생산자 프로세스는 정보를 생산하고 소비자 프로세스는 정보를 소비한다. 예를 들어, 컴파일러는 어셈블리 코드를 생산하고, 어셈블러는 이것을 소비한다. 어셈블러는 이어 목적 모듈(object
module)을 생산할 수 있고, 적재기(loader)는 이들을 소비한다.
- 생산자 소비자 문제는 클라이언트 서버 패러다임을 위한 유용한 은유를 제공한다. 일반적으로 우리는 서버를 생산자로 클라이언트를 소비자로 생각한다. 예를 들면, 웹 서버는 HTML 파일과 이미지와
같은 웹 콘텐츠를 생산(제공)하고, 이 자원들을 요청한 클라이언트 웹 브라우저가 소비하게 된다(즉, 읽는다).


- 생산자-소비자 문제의 하나의 해결책은 공유 메모리를 사용하는 것이다. 생산자와 소비자 프로세스들이 병행으로 실행되도록 하려면, 생산자가 정보를 채워 넣고 소비자가 소모할 수 있는 항목들의
버퍼가 반드시 사용 가능해야 한다.
- 이 버퍼는 생상자와 소비자 프로세스가 공유하는 메모리 영역에 존재하게 된다. 생산자가 한 항목을 생산하고, 그동안에 소비자는 다른 항목을 소비할 수 있다. 생산자와 소비자가 반드시
동기화되어야 생산되지도 않은 항목들을 소비자가 소비하려고 시도하지 않을 것이다.


- 두 가지 유형의 버퍼를 사용할 수 있다. 
- 무한 버퍼(unbounded buffer)의 생산자 소비자 문제에서는 버퍼의 크기에 실질적인 한계가 없다. 소비자는 새로운 항목을 기다려야만 할 수도 있지만 생산자는 항상 새로운 항목을 
생산할 수 있다.
- 유한 버퍼(bounded buffer)는 버퍼의 크기가 고정되어 있다고 가정한다. 이 경우 버퍼가 비어 있으면 소비자는 반드시 대기해야 하며, 모든 버퍼가 채워져 있으면 생산자가 대기해야 한다.
- 유한 버퍼가 공유 메모리를 사용한 프로세스간 통신을 어떻게 하는 지 살펴보자. 다음 변수들은 생산자와 소비자 프로세스가 공유하는 메모리 영역에 존재한다.
```text
#define BUFFER_SIZE 10

typedef struct {
    ...
} item;

item buffer[BUFFER_SIZE];
int in = 0;
int out = 0;
```
- 공유 버퍼는 두 개의 논리 포인터 in, out을 갖는 원형 배열로 구현된다. 변수 indㅡㄴ 버퍼 내에서 다음으로 비어 있는 위치를 가리키며, out은 버퍼 내에서 첫 번째로 채워져 있는 위치를
가리킨다. in == out 일 때 버퍼는 비어 있고, ((in + 1) % BUFFER_SIZE) == out 이면 버퍼는 가득 차 있다.


- 생산자와 소비자의 코드를 보자.
- 공유 메모리를 사용한 생산자 프로세스
```text
item next_produced;

while (true) {
    /* produce an item in next_produced */

    while (((in + 1) % BUFFER_SIZE) == out)
        ; /* do nothing */
    
    buffer[in] = next_produced;
    in = (in + 1) % BUFFER_SIZE;
}
```
- 공유 메모리를 사용한 소비자 프로세스
```text
item next_consumed;

while (true) {
    while (in == out)
        ; /* do nothing */
    
    next_consumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE;
    
    /* consume the item in next_consumed */
}
```
- 생산자 프로세스는 next_produced 라는 지역 변수에 다음번 생산되는 item을 저장하고 있다. 소비자 코드는 next_consumed라는 지역 변수에 다음번 소비되는 item을 저장하고 있다.
- 이 방법은 최대 BUFFER_SIZE - 1 까지만을 버퍼에 수용할 수 있다.

