# 3.3 프로세스에 대한 연산 (Operation on Processes)
- 대부분의 시스템에서 프로세스는 병행 실행될 수 있으며, 반드시 동적으로 생성되고 제거되어야 한다. 그러므로 운영체제는 프로세스 생성 및 종료를 위한 기법을 제공해야 한다.
- 이 절에서는 프로세스 생성 기법과 UNIX, Windows 시스템에서의 프로세스 생성에 관해 설명

## 3.3.1 프로세스 생성 (Process Creation)
- 실행되는 동안 프로세스는 여러 개의 새로운 프로세스들을 생성할 수 있다. 생성하는 프로세스를 부모 프로세스라고 부르고, 새로운 프로세스는 자식 프로세스라고 부른다.
- 이 새로운 프로세스들은 각각 다시 다른 프로세스들을 생성할 수 있으며, 그 결과 프로세스의 트리를 형성한다.


- UNIX, Linux 및 Windows와 같은 대부분의 현대 운영체제들은 유일한 프로세스 식별자(pid)를 사용하여 프로세스를 구분하는데 이 식별자는 보통 정수이다. 
- pid는 시스템의 각 프로세스에 고유한 값을 가지도록 할당된다. 이 식별자를 통해 커널이 유지하고 있는 프로세스의 다양한 속성에 접근하기 위한 찾아보기(index)로 사용된다.


- 129p. 그림 3.7 은 Linux 운영체제의 전형적인 프로세스 트리이며, 프로세스 이름과 pid를 보인다(Linux는 태스크라는 용어를 더 선호하고 있다. 프로세스 용어 느슨하게 사용).
- 언제나 pid가 1인 systemd 프로세스가 모든 사용자 프로세스의 루트 부모 프로세스 역할을 수행하고 시스템이 부트될 때 생성되는 첫 번째 사용자 프로세스이다.
- 시스템이 부팅되면 systemd 프로세스는 웹 또는 프린트 서버, ssh 서버 등이 포함된다. 그림 3.7에서 systemd의 두 자식 프로세스 logind와 sshd 프로세스를 볼 수 있다.
- logind 프로세스는 시스템에 직접 로그인하는 클라이언트를 관리하는 책임을 진다. 이 그림에서 클라이언트는 로그인한 후 bash 셸을 사용하고 있는데, 셸의 pid는 8416이 할당되었따.
- bash 명령어 라인 인터페이스를 사용하여 이 사용자는 ps 프로세스와 vim 편집기 프로세스를 생성하였다. sshd 프로세스는 ssh를 (secure shell의 약자)를 사용하여 시스템에 접속하는
클라이언트의 관리를 책임진다.
- UNIX와 Linux 시스템에서는 ps 명령어를 이용하여 프로세스들의 목록을 얻을 수 있다. 예를 들어 `ps -el`과 같은 명령은 현재 시스템에 활성화되어 있는 모든 프로세스의 정보를 나열한다.
- 프로세스들의 부모 프로세스를 systemd가 나올 때까지 재귀적으로 추가하면 프로세스 트리를 구축하는 것은 쉽다. (게다가 Linux는 시스템의 모든 프로세스 트리를 보여주는 pstree 명령 제공)


- 일반적으로 프로세스가 자식 프로세스를 생성할 때, 그 자식 프로세스는 작업을 수행하기 위해 특정 자원(CPU 시간, 메모리, 파일, 입출력 장치)이 필요하다.
- 자식 프로세스는 이 자원을 운영체제로부터 직접 얻거나, 부모 프로세스가 가진 자원의 부분 집합만을 사용하도록 제한될 수 있다. 
- 부모 프로세스는 자원을 분할하여 자식 프로세스들에게 나누어 주거나 메모리나 파일과 같은 일부 자원들은 자식 프로세스들이 같이 사용하게 할 수도 있다.
- 부모 프로세스 자원의 일부분만을 사용하도록 자식 프로세스가 쓸 수 있게 제한하며, 자식 프로세스들을 많이 생성하여 시스템을 과부하 상태로 만드는 프로세스를 방지할 수 있다.


- 물리적, 논리적 자원을 제공하는 것 이외에 부모 프로세스는 자식 프로세스에 초기화 데이터(입력)을 하위 프로세스에 전달할 수 있다.
- 예를 들어, hw1.c라는 파일의 내용을 단말기의 화면에 나타내는 기능을 하는 프로세스를 고려해 보면, 이 프로세스가 생성될 때, 부모 프로세스로부터 입력 데이터로 hw1.c라는 파일 이름을
얻을 수 있다.
- 이 파일 이름을 사용해 파일을 열고 내용을 출력할 수 있다. 프로세스는 또한 출력 장치의 이름도 전달받을 수 있다.
- 대체 방안으로, 어떤 운영체제는 자식 프로세스에 자원을 전달한다. 이와 같은 시스템에서는, 새로운 프로세스는 hw1.c와 터미널 장치에 해당하는 두 개의 열린 파일을 전달받고 단순히
두 장치 사이에서 데이터를 전송하는 작업만 하면 된다.


- 프로세스가 새로운 프로세스를 생성할 때, 두 프로세스를 실행시키는 데 두 가지 가능한 방법이 존재
1. 부모는 자식과 병행하게 실행을 계속한다.
2. 부모는 일부 또는 모든 자식이 실행을 종료할 때까지 기다린다.
- ㄹ새로운 프로세스들이 주소 공간 측면에서 볼 때 다음과 같은 두 가지 가능성이 있다.
1. 자식 프로세스는 부모 프로세스의 복사본이다. (자식 프로세스는 부모와 똑같은 프로그램과 데이터를 가진다.)
2. 자식 프로세스가 자신에게 적재될 새로운 프로그램을 가지고 있다.

- 이들의 차이점을 보기 전에, UNIX 운영체제를 고려해보자. UNIX에서 각 프로세스는 프로세스 식별자 (identifier)로 확인되는데 이것은 유일한 정수이다. 새로운 프로세스는 fork() 시스템
콜로 생성된다.
- 새로운 프로세스는 원래 프로세스의 주소 공간의 복사본으로 구성된다. 이 기법은 부모 프로세스가 쉽게 자식 프로세스와 통신할 수 있게 한다.
- 두 개의 프로세스들(부모, 자식)은 fork() 후의 명령어에서부터 실행을 계속하며, 이 때 한 가지 다른점은 fork()의 반환 코드가 서로 다르다는 것이다. 자식 프로세스의 (0이 아닌) 식별자가
부모로 반환되는 데 반해, 새로운(자식) 프로세스는 '0'이 반환된다.


- fork() 시스템 콜 다음에 두 프로세스 중 한 프로세스가 exec() 시스템 콜을 사용하여 자신의 메모리 공간을 새로운 프로그램으로 교체한다. 
- exec() 시스템 콜은 이진 파일을 메모리로 적재(load)하고 (이 때 exec() 시스템 콜을 포함하는 원래 프로그램의 메모리 이미지를 파괴) 그 프로그램의 실행을 시작한다.
- 이와 같은 방법으로 두 프로세스는 통신을 할 수 있으며, 그리고 이어 그들 각자의 길을 간다.
- 그 후 부모는 더 많은 자식을 생성할 수 있으며, 또는 자식이 실행하는 동안 할 일이 없으면, 자식이 종료될 때까지 준비 큐에서 자신을 제거하기 위해 wait() 시스템 콜을 한다.
- exec()을 호출하면 프로세스의 주소 공간을 새 프로그램으로 덮어쓰기 때문에 exec() 시스템 콜은 오류가 발생하지 않는 한 제어를 반환하지 않는다.
```C
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
int main()
{
    pid t pid;
    
    /* fork a child process */
    pid = fork();
    
    if (pid < 0) { /* error occurred */
        fprintf(stderr, "Fork Failed");
        return 1;
    }
    else if (pid == 0) { /* child process */
        execlp("/bin/ls","ls",NULL);
    }
    else { /* parent process */
        /* parent will wait for the child to complete */
        wait(NULL);
        printf("Child Complete");
    }
    
    return 0;
}
```
- 위 C 프로그램은 앞에서 설명한 시스템 콜을 보인다. 우리는 이제 동일한 프로그램의 복사본을 실행하는 두 개의 서로 다른 프로세스를 갖는다.
- 우리는 이제 동일한 프로그램의 복사본을 실행하는 두 개의 서로 다른 프로세스를 갖는다. 유일한 차이점은 자식 프로세스에 보이는 pid의 값은 0이고, 반면에 부모 프로세스에게 보이는 pid
값은 0보다 큰 정수 값(사실 이 값은 자식 프로세스의 pid)이라는 것이다. 자식 프로세스는 열린 파일과 같은 자원뿐 아니라 특권과 스케줄링 속성을 부모 프로세스로부터 상속받는다.
- 그런 후에 자식 프로세스는 execlp() 시스템 콜(exec() 시스템 콜의 한 버전)을 사용해 자신의 주소 공간을 UNIX 명령 /bin/ls (디렉터리 목록을 얻기 위해 사용됨)로 덮어쓴다.
- 부모는 wait() 시스템 콜로 자식 프로세스가 끝나기를 기다린다. 자식 프로세스가 끝나면 (암시적 또는 명시적으로 exit()을 사용하여), 부모 프로세스는 wait() 호출로부터 재개하여,
exit() 시스템 콜을 사용하여 끝낸다.
- 물론 자식 프로세스가 exec()을 호출하지 않고 부모 프로세스의 복사본을 계속 실행하는 것을 막을 방법은 없다. 이 시나리오에서 부모와 자식은 같은 코드를 실행하는 병행 실행 프로세스이다.
자식은 부모의 복사본이기 때문에 각 프로세스는 모든 데이터에 대해 자신만의 복사본을 가지고 있다.
```C
#include <stdio.h>
#include <windows.h>
int main(VOID)
{
    STARTUPINFO si;
    PROCESS INFORMATION pi;
    /* allocate memory */
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));
    
    /* create child process */
    if (!CreateProcess(NULL, /* use command line */
        "C:∖∖WINDOWS∖∖system32∖∖mspaint.exe", /* command */
        NULL, /* don’t inherit process handle */
        NULL, /* don’t inherit thread handle */
        FALSE, /* disable handle inheritance */
        0, /* no creation flags */
        NULL, /* use parent’s environment block */
        NULL, /* use parent’s existing directory */
        &si,
        &pi))
    {
        fprintf(stderr, "Create Process Failed");
        return -1;
    }
    
    /* parent will wait for the child to complete */
    WaitForSingleObject(pi.hProcess, INFINITE);
    printf("Child Complete");
    
    /* close handles */
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}
```
- 다른 예로 Windows 에서의 프로세스 생성에 대해 고려한다. 프로세스는 Windows API의 CreateProcess() 함수를 이용해 생성되는 데 이 함수는 부모 프로세스가 새로운 자식 프로세스를
생성한다는 점에서 fork()와 유사하다. 
- 그러나 fork()가 부모 프로세스로부터 주소 공간을 상속받는 자식 프로세스를 생성하는 반면에 CreateProcess()는 자식 프로세스가 생성될 때, 주소 공간에 명시된 프로그램을 적재한다.
더욱이 fork()가 아무런 인자가 전달되지 않는 반면에 CreateProcess()는 10개 이상의 매개변수를 요구한다.


- 위 C 프로그램은 mspaint.exe를 적재하는 자식 프로세스를 생성하는 CreateProcess()를 설명하고 있다. 우리는 CreateProcess()에게 전달되는 10개의 매개 변수의 중에서 많은 수를
디폴트, 값으로 선택하였다.
- CreateProcess() 함수에 전달된 두 개의 매개 변수는 STARTUPINFO와 PROCESS_INFORMATION 구조체의 인스턴스이다.
- STARTUPINFO는 윈도 크기와 모양 표준 입력과 출력 파일에 대한 핸들과 같은 새로운 프로세스의 특성을 지정한다.
- PROCESS_INFORMATION 구조체는 새로 생성된 프로세스와 스레드에 대한 핸들과 식별자들을 포함하고 있다.
- CreateProcess()를 진행하기 전에 각각의 구조체가 쓸 메모리를 할당하기 위해 ZeroMemory() 함수를 호출하였다.


- CreateProcess()에 전달된 처음 두 매개 변수는 응용 프로그램 이름과 명령어 라인 매개변수이다. 만일 응용 프로그램의 이름이 NULL 이면, 명령어 라인 매개변수가 적재할 응용 프로그램을
지정한다.
- 이 예제에서 우리는 Microsoft Windows의 mspaint.exe 응용 프로그램을 적재하고 있다. 이 이후의 매개 변수에 대해서는 디폴트 값을 사용하여 프로세스와 스레드 핸들을 상속받고 생성 
플래그가 없다고 명시한다. 
- 또한 부모 프로세스의 기존 환경 블록을 사용하고시작 디렉터리로 부모의 시작 디렉터리를 사용하였따.
- 마지막으로 프로그램 초기에 생성된 STARTUPINFO와 PROCESS_INFORMATION 구조체를 가리키는 포인터를 매개변수로 전달한다.
- 이전 코드에서 부모 프로세스는 wait() 시스템 콜을 호출해 자식 프로세스가 끝나기를 기다린다. 이와 동일한 Windows API의 함수는 WaitForSingleObject()이고, 이 함수는 자식 
프로세스의 핸들 (pi.hProcess)을 전달받고 이 프로세스가 종료되기를 기다린다.
- 자식 프로세스가 종료하면 제어는 부모 프로세스의 WaitForSingleObject()에서 반환된다.

## 3.3.2 프로세스 종료
- 프로세스가 마지막 문장의 실행을 끝내고, exit 시스템 콜을 사용해 운영체제에 자신의 삭제를 요청하면 종료한다.
- 이 시점에서, 프로세스는 자신을 기다리고 있는 부모 프로세스에 기다리고 있는 부모 프로세스에(wait 시스템 콜을 통해) 상태값(통상 정수값)을 반환할 수 있다.
- 물리 메모리의 가상 메모리, 열린 파일, 입출력 버퍼를 포함한 프로세스의 모든 자원이 할당 해제되고 운영체제로 반납된다.


- 프로세스 종료가 발생하는 다른 경우가 있다. 한 프로세스는 적당한 시스템 콜(예를 들어, Windows의 TerminateProcess())을 통해서 다른 프로세스의 종료를 유발할 수 있다.
- 일반적으로, 그런 시스템 콜은 단지 종료될 프로세스의 부모만이 호출할 수 있다. 그렇지 않으면, 사용자 또는 오작동하는 프로세스가 다른 사용자의 프로세스를 임으로 중단(kill)시킬 수 있을
것이다. 부모가 자식을 종료시키기 위해서는 자식의 pid를 알아야 한다. 따라서 한 프로세스가 새로운 프로세스를 만들 때, 새로 만들어진 프로세스의 id가 부모에게 전달된다.


- 부모는 다음과 같이 여러 이유로 자식 중 하나의 실행을 종료할 수 있다.
  - 자식이 자신에게 할당된 자원을 초과하여 사용할 때, 이떄는 부모가 자식들의 상태를 검사할 수 있는 방편이 주어져야 한다.
  - 자식에게 할당된 태스크가 더 이상 필요 없을 때
  - 부모가 exit를 하는데, 운영체제는 부모가 exit 한 후에 자식이 실행을 계속하는 것을 허용하지 않는 경우
- 일부 시스템에서는 부모 프로세스가 종료한 이후에 자식 프로세스가 존재할 수 없다. 그러한 시스템에서는 프로세스가 종료되면 (정상이든 비정상이든) 그로부터 비롯된 모든 자식 프로세스들도
종료되어야 한다. 이것을 연쇄식 종료 (cascading termination)라고 부르며 이 작업은 운영체제가 시행한다.
- 프로세스 실행과 종료를 설명하기 위해서 Linux와 UNIX 시스템에서 exit() 시스템 콜을 사용하여 프로세스를 종료시키는 것을 고려해보자. exit() 시스템 콜은 종료 상태를 나타내는
인자를 전달 받는다.
```text
/* 1인 상태로 exit 1 */
exit(1);
```
- 사실 정상적인 종료에서 exit()은 위와 같이 직접적으로 호출되거나 UNIX 실행 파일에 추가되는 C 실행시간 라이브러리가 디폴트로 exit() 호출을 추가하기 떄문에 간접적으로 호출될 수 있다.


- 부모 프로세스는 wait() 시스템 콜을 사용해서 자식 프로세스가 종료할 때를 기다릴 수 있다. wait() 시스템 콜은 부모가 자식의 종료 상태를 얻어낼 수 있도록 하나의 인자를 전달받는다.
- 이 시스템 콜은 부모가 어느 자식이 종료되었는지 구별할 수 있도록 종료된 자식의 프로세스 식별자를 반환한다.
```text
pid_t pid;
int status;

pid = wait(&status);
```
- 프로세스가 종료하면 사용하던 자원은 운영체제가 되찾아 간다. 그러나 프로세스의 종료 상태가 저장되는 프로세스 테이블의 해당 항목은 부모 프로세스가 wait()를 호출할 때까지 남아 있게 된다.
- 종료되었지만 부모 프로세스가 아직 wait() 호출을 하지 않은 프로세스를 좀비(zombie) 프로세스라고 한다. 종료하게 되면 모든 프로세스는 좀비 상태가 되지만 아주 짧은 시간동안만 머무른다.
부모가 wait()를 호출하면 좀비 프로세스의 프로세스 식별자와 프로세스 테이블의 해당 항목이 운영체제에 반환된다.


- 부모 프로세스가 wait()를 호출하는 대신 종료한다면 자식 프로세스는 고아(orphan) 프로세스라고 부른다. 전통적인 UNIX 는 고아 프로세스의 새ㅔ로운 부모 프로세스로 init 프로세스를
지정함으로써 이 문제를 해결한다(init 프로세스가 UNIX 시스템에서 프로세스 계층 구조의 루트에 위치). init 프로세스는 주기적으로 wait()를 호출하여 고아 프로세스의 종료 상태를 
수집하고 프로세스 식별자와 프로세스 테이블 항목을 반환한다.
- 대ㅐ부분의 Linux 시스템은 init을 systemd로 대체했지만, 후자의 프로세스는 여전히 동일한 역할을 수행할 수 있지만 Linux 는 systemd 이외의 프로세스가 고아 프로세스를 상속하고 
종료를 관리하도록 허용한다.

### 3.3.2.1 Android 프로세스 계층 (Android Process Hierarchy)
- 제한된 메모리와 같은 자원 제약 때문에 모바일 운영체제는 제한된 시스템 자원을 회수하기 위해 기존 프로세스를 종료해야 할 수도 있다.
- Android는 임의의 프로세스를 종료하지 않고 프로세스의 중요도 계층을 식별했으며, 시스템이 프로세스를 종료하여 새로운 또는 보다 중요한 프로세스를 위한 자원을 확보해야 할 경우 중요도가
낮은 프로세스부터 종료한다. 가장 중요한 순서부터 프로세스를 분류하면 다음과 같다.
    - 전경 프로세스 (foreground process) : 사용자가 현재 상호 작용하고 있는 응용 프로그램을 나타내며, 화면에 보이는 현재 프로세스
    - 가시적 프로세스 (visible process) : 전경에서 직접 볼 수 없지만, 전경 프로세스가 참조하는 활동(즉, 현재 상태가 전경 프로세스에 표시되는 활동을 수행하는 프로세스)을 수행하는
    프로세스
    - 서비스 프로세스(service process) : 백그라운드 프로세스와 유사하지만 사용자가 인지할 수 있는 활동(예 : 음악 스트리밍)을 수행하는 프로세스
    - 백그라운드 프로세스(background process) : 활동을 수행하고 있지만 사용자가 인식하지 못하는 프로세스
    - 빈 프로세스 (empty process) : 응용 프로그램과 관련된 활성 구성요소가 없는 프로세스
- 시스템 자원을 회수해야 하는 경우 Android는 먼저 빈 프로세스를 종료한 다음 백그라운드 프로세스 등의 순서로 종료한다.
- 프로세스에는 중요도 순위가 지정되고 Android는 프로세스에 가능한 한 높은 순위를 지정하려고 한다. 예를 들어, 프로세스가 서비스를 제공하고 있고 가시적이면 더 중요한 가시적 분류가 지정됨


- 또한 Android 개발 관행은 프로세스 수명주기 지침을 따르는 것을 권장한다. 이 지침을 준수하면 프로세스 상태는 종료 전에 저장되고 사용자가 응용 프로그램으로 다시 전환하면 저장된
상태에서부터 재개된다.

